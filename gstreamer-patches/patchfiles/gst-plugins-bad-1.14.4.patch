diff --git a/configure.ac b/configure.ac
index 943412cfb..14627a124 100644
--- a/configure.ac
+++ b/configure.ac
@@ -945,11 +945,17 @@ AG_GST_CHECK_FEATURE(CUDA, [NVIDIA CUDA API],, [
       CUDA_LIBS="-L$CUDA_PREFIX/lib -L$CUDA_PREFIX/lib64 -L$CUDA_PREFIX/lib/stubs -L$CUDA_PREFIX/lib64/stubs -lcuda -lcudart"
     fi
   else
-    PKG_CHECK_MODULES([CUDA], [cuda-8.0 cudart-8.0],, [
-      PKG_CHECK_MODULES([CUDA], [cuda-7.5 cudart-7.5],, [
-        PKG_CHECK_MODULES([CUDA], [cuda-7.0 cudart-7.0],, [
-          PKG_CHECK_MODULES([CUDA], [cuda-6.5 cudart-6.5],, [
-            AC_MSG_WARN([Could not find cuda headers/libraries])])])])])
+    PKG_CHECK_MODULES([CUDA], [cuda-10.1 cudart-10.1],, [
+      PKG_CHECK_MODULES([CUDA], [cuda-10.0 cudart-10.0],, [
+        PKG_CHECK_MODULES([CUDA], [cuda-9.2 cudart-9.2],, [
+          PKG_CHECK_MODULES([CUDA], [cuda-9.1 cudart-9.1],, [
+            PKG_CHECK_MODULES([CUDA], [cuda-9.0 cudart-9.0],, [
+              PKG_CHECK_MODULES([CUDA], [cuda-8.0 cudart-8.0],, [
+                PKG_CHECK_MODULES([CUDA], [cuda-7.5 cudart-7.5],, [
+                  PKG_CHECK_MODULES([CUDA], [cuda-7.0 cudart-7.0],, [
+                    PKG_CHECK_MODULES([CUDA], [cuda-6.5 cudart-6.5],, [
+                      AC_MSG_WARN([Could not find cuda headers/libraries])])])])])])])])])])
+
   fi
 
   HAVE_CUDA_H=no
diff --git a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
index a0c075b66..a5f366f97 100644
--- a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
+++ b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
@@ -2838,7 +2838,14 @@ gst_adaptive_demux_stream_wait_manifest_update (GstAdaptiveDemux * demux,
    * us to download in the playlist or the playlist
    * became non-live */
   while (TRUE) {
-    GST_DEBUG_OBJECT (demux, "No fragment left but live playlist, wait a bit");
+    ret=gst_element_post_message (GST_ELEMENT_CAST (demux),
+        gst_message_new_element (GST_OBJECT_CAST (demux),
+            gst_structure_new ("playlist-overrun",
+              "manifest-uri", G_TYPE_STRING,demux->manifest_uri, 
+              "uri", G_TYPE_STRING,demux->manifest_uri,
+              "manifest-download-start", GST_TYPE_CLOCK_TIME,GST_CLOCK_TIME_NONE,
+              "manifest-download-stop", GST_TYPE_CLOCK_TIME, gst_util_get_timestamp (), NULL)));
+    GST_DEBUG_OBJECT (demux, "No fragment left but live playlist, wait a bit. Message sent:%d",ret);
 
     /* get the manifest_update_lock while still holding the manifest_lock.
      * This will prevent other threads to signal the condition (they will need
@@ -4024,7 +4031,12 @@ gst_adaptive_demux_updates_loop (GstAdaptiveDemux * demux)
             gst_flow_get_name (ret));
         next_update = gst_adaptive_demux_get_monotonic_time (demux)
             + klass->get_manifest_update_interval (demux) * GST_USECOND;
-      } else {
+        gst_element_post_message(GST_ELEMENT_CAST(demux),
+            gst_message_new_element(GST_OBJECT_CAST(demux),
+                gst_structure_new("playlist-dead",
+                    "manifest-uri",G_TYPE_STRING,demux->manifest_uri,
+                    NULL)));
+     } else {
         GST_ELEMENT_ERROR (demux, STREAM, FAILED,
             (_("Internal data stream error.")), ("Could not update playlist"));
         GST_DEBUG_OBJECT (demux, "Stopped updates task because of error");
diff --git a/gst-libs/gst/mpegts/Makefile.am b/gst-libs/gst/mpegts/Makefile.am
index f264e33a7..9765fdd27 100644
--- a/gst-libs/gst/mpegts/Makefile.am
+++ b/gst-libs/gst/mpegts/Makefile.am
@@ -5,7 +5,8 @@ libgstmpegts_@GST_API_VERSION@_la_SOURCES = \
 	gstmpegtsdescriptor.c \
 	gst-dvb-descriptor.c \
 	gst-dvb-section.c \
-	gst-atsc-section.c
+	gst-atsc-section.c \
+        gst-scte-section.c
 
 libgstmpegts_@GST_API_VERSION@includedir = \
 	$(includedir)/gstreamer-@GST_API_VERSION@/gst/mpegts
diff --git a/gst-libs/gst/mpegts/gst-scte-section.h b/gst-libs/gst/mpegts/gst-scte-section.h
index babab342d..45d948993 100644
--- a/gst-libs/gst/mpegts/gst-scte-section.h
+++ b/gst-libs/gst/mpegts/gst-scte-section.h
@@ -52,6 +52,7 @@ typedef enum {
   GST_MPEGTS_STREAM_TYPE_SCTE_SUBTITLING = 0x82,   /* Subtitling data */
   GST_MPEGTS_STREAM_TYPE_SCTE_ISOCH_DATA = 0x83,   /* Isochronous data */
   /* 0x84 - 0x94 : defined in other specs */
+  GST_MPEGTS_STREAM_TYPE_SCTE_SPLICING   = 0x86,   /* Lajos: SCTE35 stream type */
   GST_MPEGTS_STREAM_TYPE_SCTE_DST_NRT    = 0x95,   /* DST / NRT data */
   /* 0x96 - 0xaf : defined in other specs */
   GST_MPEGTS_STREAM_TYPE_SCTE_DSMCC_DCB  = 0xb0,   /* Data Carousel Type B */
@@ -97,6 +98,52 @@ typedef enum {
 
 } GstMpegtsSectionSCTETableID;
 
+typedef struct _GstMpegtsScteSpliceInsert GstMpegtsScteSpliceInsert;
+
+struct _GstMpegtsScteSpliceInsert
+{
+  guint32 splice_event_id;
+  gboolean splice_event_cancel_indicator;
+  gboolean out_of_network_indicator;
+  gboolean program_splice_flag;
+  gboolean duration_flag;
+  gboolean splice_immediate_flag;
+  gboolean time_specified_flag;
+  guint64 pts_time;
+  guint16 unique_program_id;
+  guint8 avail_num;
+  guint8 avails_expected;
+} ;
+
+typedef struct _GstMpegtsScteSpliceInfo GstMpegtsScteSpliceInfo;
+
+struct _GstMpegtsScteSpliceInfo
+{
+  guint8 table_id;
+  gboolean section_syntax_indicator;
+  gboolean private_indicator;
+  guint16 section_length;
+  guint8 protocol_version;
+  gboolean encrypted_packet;
+  guint8 encryption_algorith;
+  guint64 pts_adjustment;
+  guint8 cw_index;
+  guint16 tier;
+  guint16 splice_command_length;
+  guint8 splice_command_type;
+  GstMpegtsScteSpliceInsert splice_insert;
+  GPtrArray *descriptors;
+} ;
+
+
+GST_MPEGTS_API
+const GstMpegtsScteSpliceInfo *
+gst_mpegts_section_get_scte_splice_info (GstMpegtsSection *section);
+
+GST_MPEGTS_API
+const GstMpegtsScteSpliceInfo*
+gst_mpegts_set_scte_splice_info(GstStructure *s);
+
 G_END_DECLS
 
 #endif  /* GST_SCTE_SECTION_H */
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.c b/gst-libs/gst/mpegts/gstmpegtssection.c
index 01fc2a23d..a02385a22 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.c
+++ b/gst-libs/gst/mpegts/gstmpegtssection.c
@@ -76,6 +76,7 @@ static GQuark QUARK_EIT;
 static GQuark QUARK_TDT;
 static GQuark QUARK_TOT;
 static GQuark QUARK_SECTION;
+static GQuark QUARK_SIT;
 
 static GType _gst_mpegts_section_type = 0;
 #define MPEG_TYPE_TS_SECTION (_gst_mpegts_section_type)
@@ -294,6 +295,9 @@ _mpegts_section_get_structure (GstMpegtsSection * section)
     case GST_MPEGTS_SECTION_TOT:
       quark = QUARK_TOT;
       break;
+    case GST_MPEGTS_SECTION_SCTE_SPLICING:
+      quark = QUARK_SIT;
+      break;
     default:
       GST_DEBUG ("Creating structure for unknown GstMpegtsSection");
       quark = QUARK_SECTION;
@@ -1010,7 +1014,7 @@ gst_mpegts_initialize (void)
   QUARK_TDT = g_quark_from_string ("tdt");
   QUARK_TOT = g_quark_from_string ("tot");
   QUARK_SECTION = g_quark_from_string ("section");
-
+  QUARK_SIT = g_quark_from_string ("sit");
   __initialize_descriptors ();
 }
 
@@ -1075,6 +1079,9 @@ _identify_section (guint16 pid, guint8 table_id)
       if (pid == 0x1ffb)
         return GST_MPEGTS_SECTION_ATSC_STT;
       break;
+    case GST_MTS_TABLE_ID_SCTE_SPLICE:  
+        return GST_MPEGTS_SECTION_SCTE_SPLICING;
+      break;
     default:
       /* Handle ranges */
       if (table_id >= GST_MTS_TABLE_ID_EVENT_INFORMATION_ACTUAL_TS_PRESENT &&
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.h b/gst-libs/gst/mpegts/gstmpegtssection.h
index 3b8846c8a..3ba29dce4 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.h
+++ b/gst-libs/gst/mpegts/gstmpegtssection.h
@@ -78,7 +78,8 @@ typedef enum {
   GST_MPEGTS_SECTION_ATSC_MGT,
   GST_MPEGTS_SECTION_ATSC_ETT,
   GST_MPEGTS_SECTION_ATSC_EIT,
-  GST_MPEGTS_SECTION_ATSC_STT
+  GST_MPEGTS_SECTION_ATSC_STT,
+  GST_MPEGTS_SECTION_SCTE_SPLICING
 } GstMpegtsSectionType;
 
 /**
diff --git a/gst-libs/gst/mpegts/meson.build b/gst-libs/gst/mpegts/meson.build
index 2ee420926..af07ea95a 100644
--- a/gst-libs/gst/mpegts/meson.build
+++ b/gst-libs/gst/mpegts/meson.build
@@ -4,6 +4,7 @@ mpegts_sources = [
   'gst-dvb-descriptor.c',
   'gst-dvb-section.c',
   'gst-atsc-section.c',
+  'gst-scte-section.c',
 ]
 
 mpegts_headers = [
diff --git a/gst/mpegtsdemux/meson.build b/gst/mpegtsdemux/meson.build
index 4cd448c65..09174cc74 100644
--- a/gst/mpegtsdemux/meson.build
+++ b/gst/mpegtsdemux/meson.build
@@ -12,7 +12,8 @@ gstmpegtsdemux = library('gstmpegtsdemux',
   c_args : gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API'],
   include_directories : [configinc, libsinc],
   dependencies : [gstcodecparsers_dep, gstmpegts_dep, gsttag_dep,
-		  gstpbutils_dep, gstaudio_dep, gstbase_dep, mathlib],
+                  gstpbutils_dep, gstaudio_dep, gstbase_dep, libm],
   install : true,
   install_dir : plugins_install_dir,
 )
+pkgconfig.generate(gstmpegtsdemux, install_dir : plugins_pkgconfig_install_dir)
diff --git a/gst/mpegtsdemux/mpegtsbase.c b/gst/mpegtsdemux/mpegtsbase.c
index 5180c2ee5..cd3387116 100644
--- a/gst/mpegtsdemux/mpegtsbase.c
+++ b/gst/mpegtsdemux/mpegtsbase.c
@@ -83,12 +83,18 @@ static GstFlowReturn mpegts_base_chain (GstPad * pad, GstObject * parent,
     GstBuffer * buf);
 static gboolean mpegts_base_sink_event (GstPad * pad, GstObject * parent,
     GstEvent * event);
+static gboolean mpegts_base_sink_query (GstPad * pad, GstObject * parent,
+    GstQuery * query);
+static gboolean mpegts_base_default_sink_query (MpegTSBase * base,
+    GstQuery * query);
 static GstStateChangeReturn mpegts_base_change_state (GstElement * element,
     GstStateChange transition);
 static gboolean mpegts_base_get_tags_from_eit (MpegTSBase * base,
     GstMpegtsSection * section);
 static gboolean mpegts_base_parse_atsc_mgt (MpegTSBase * base,
     GstMpegtsSection * section);
+static gboolean mpegts_base_parse_scte_splice (MpegTSBase *base,
+    GstMpegtsSection *section);
 static gboolean remove_each_program (gpointer key, MpegTSBaseProgram * program,
     MpegTSBase * base);
 
@@ -137,7 +143,7 @@ mpegts_base_class_init (MpegTSBaseClass * klass)
       g_param_spec_boolean ("parse-private-sections", "Parse private sections",
           "Parse private sections", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-
+  klass->sink_query = GST_DEBUG_FUNCPTR (mpegts_base_default_sink_query);
 }
 
 static void
@@ -150,6 +156,7 @@ mpegts_base_set_property (GObject * object, guint prop_id,
     case PROP_PARSE_PRIVATE_SECTIONS:
       base->parse_private_sections = g_value_get_boolean (value);
       break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
   }
@@ -228,6 +235,7 @@ mpegts_base_init (MpegTSBase * base)
       mpegts_base_sink_activate_mode);
   gst_pad_set_chain_function (base->sinkpad, mpegts_base_chain);
   gst_pad_set_event_function (base->sinkpad, mpegts_base_sink_event);
+  gst_pad_set_query_function (base->sinkpad, mpegts_base_sink_query);
   gst_element_add_pad (GST_ELEMENT (base), base->sinkpad);
 
   base->disposed = FALSE;
@@ -243,7 +251,7 @@ mpegts_base_init (MpegTSBase * base)
 
   base->push_data = TRUE;
   base->push_section = TRUE;
-
+  base->base_offset = 0;
   mpegts_base_reset (base);
 }
 
@@ -434,6 +442,19 @@ mpegts_base_get_program (MpegTSBase * base, gint program_number)
   return program;
 }
 
+MpegTSBaseProgram*
+mpegts_base_get_program_from_pid(MpegTSBase *base, gint pid)
+{
+    GHashTableIter iter;
+    gpointer key, value;
+    g_hash_table_iter_init(&iter, base->programs);
+    while (g_hash_table_iter_next(&iter, &key, &value))
+    {
+        if (((MpegTSBaseProgram*)value)->active && ((MpegTSBaseProgram*)value)->streams[pid])
+            return (MpegTSBaseProgram*)value;
+    }
+    return NULL;
+}
 static MpegTSBaseProgram *
 mpegts_base_steal_program (MpegTSBase * base, gint program_number)
 {
@@ -467,6 +488,7 @@ mpegts_base_free_program (MpegTSBaseProgram * program)
   if (program->pmt) {
     gst_mpegts_section_unref (program->section);
     program->pmt = NULL;
+    program->spliceinfo = NULL;
   }
 
   /* FIXME FIXME FIXME FREE STREAM OBJECT ! */
@@ -556,7 +578,8 @@ mpegts_base_program_add_stream (MpegTSBase * base,
     GST_DEBUG ("PID 0x%04x, registration_id %" SAFE_FOURCC_FORMAT,
         bstream->pid, SAFE_FOURCC_ARGS (bstream->registration_id));
   }
-
+  bstream->already_spliced = FALSE;
+  bstream->cc = 0;
   program->streams[pid] = bstream;
   program->stream_list = g_list_append (program->stream_list, bstream);
 
@@ -702,6 +725,7 @@ _stream_is_private_section (GstMpegtsPMTStream * stream)
     case GST_MPEGTS_STREAM_TYPE_DSMCC_D:
     case GST_MPEGTS_STREAM_TYPE_SL_FLEXMUX_SECTIONS:
     case GST_MPEGTS_STREAM_TYPE_METADATA_SECTIONS:
+    case GST_MPEGTS_STREAM_TYPE_SCTE_SPLICING:
       /* known PSI streams */
       return TRUE;
     default:
@@ -892,6 +916,7 @@ mpegts_base_activate_program (MpegTSBase * base, MpegTSBaseProgram * program,
   program->pmt = pmt;
   program->pmt_pid = pmt_pid;
   program->pcr_pid = pmt->pcr_pid;
+  program->spliceinfo = NULL;
 
   /* extract top-level registration_id if present */
   program->registration_id =
@@ -947,7 +972,7 @@ mpegts_base_apply_pat (MpegTSBase * base, GstMpegtsSection * section)
   if (G_UNLIKELY (pat == NULL))
     return FALSE;
 
-  GST_INFO_OBJECT (base, "PAT");
+  GST_DEBUG_OBJECT (base, "PAT");
 
   /* Applying a new PAT does two things:
    * * It adds the new programs to the list of programs this element handles
@@ -959,6 +984,7 @@ mpegts_base_apply_pat (MpegTSBase * base, GstMpegtsSection * section)
 
   old_pat = base->pat;
   base->pat = pat;
+  base->ts_id = section->subtable_extension;
 
   GST_LOG ("Activating new Program Association Table");
   /* activate the new table */
@@ -1147,8 +1173,8 @@ mpegts_base_handle_psi (MpegTSBase * base, GstMpegtsSection * section)
 {
   gboolean post_message = TRUE;
 
-  GST_DEBUG ("Handling PSI (pid: 0x%04x , table_id: 0x%02x)",
-      section->pid, section->table_id);
+  GST_DEBUG ("Handling PSI (pid: 0x%04x , table_id: 0x%02x, section_type:%02x)",
+      section->pid, section->table_id,section->section_type);
 
   switch (section->section_type) {
     case GST_MPEGTS_SECTION_PAT:
@@ -1170,6 +1196,11 @@ mpegts_base_handle_psi (MpegTSBase * base, GstMpegtsSection * section)
     case GST_MPEGTS_SECTION_ATSC_MGT:
       post_message = mpegts_base_parse_atsc_mgt (base, section);
       break;
+    case GST_MPEGTS_SECTION_SCTE_SPLICING:
+      GST_DEBUG("Found splicing table.");
+      GST_MEMDUMP ("Full section data", section->data,section->section_length);
+      post_message = mpegts_base_parse_scte_splice(base,section);
+      break;  
     default:
       break;
   }
@@ -1205,6 +1236,20 @@ mpegts_base_parse_atsc_mgt (MpegTSBase * base, GstMpegtsSection * section)
   return TRUE;
 }
 
+static gboolean
+mpegts_base_parse_scte_splice(MpegTSBase *base, GstMpegtsSection *section)
+{
+  const GstMpegtsScteSpliceInfo *sinfo;
+
+  sinfo=gst_mpegts_section_get_scte_splice_info(section);
+  if(G_UNLIKELY(sinfo==NULL))
+    return FALSE;
+  if(G_UNLIKELY(mpegts_base_get_program_from_pid(base, section->pid)==NULL))
+    return FALSE;
+  mpegts_base_get_program_from_pid(base, section->pid)->spliceinfo = sinfo;
+  return TRUE;
+}
+
 static gboolean
 mpegts_base_get_tags_from_eit (MpegTSBase * base, GstMpegtsSection * section)
 {
@@ -1315,7 +1360,7 @@ mpegts_base_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_SEGMENT:
       gst_event_copy_segment (event, &base->segment);
-      GST_DEBUG_OBJECT (base, "Received segment %" GST_SEGMENT_FORMAT,
+      GST_INFO_OBJECT (base, "Received segment %" GST_SEGMENT_FORMAT,
           &base->segment);
       /* Check if we need to switch PCR/PTS handling */
       if (base->segment.format == GST_FORMAT_TIME) {
@@ -1356,6 +1401,23 @@ mpegts_base_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
   return res;
 }
 
+static gboolean
+mpegts_base_default_sink_query (MpegTSBase * base, GstQuery * query)
+{
+  return gst_pad_query_default (base->sinkpad, GST_OBJECT (base), query);
+}
+
+static gboolean
+mpegts_base_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
+{
+  MpegTSBase *base = GST_MPEGTS_BASE (parent);
+
+  GST_DEBUG_OBJECT (base, "Got query %s",
+      gst_query_type_get_name (GST_QUERY_TYPE (query)));
+
+  return GST_MPEGTS_BASE_GET_CLASS (base)->sink_query (base, query);
+}
+
 static GstFlowReturn
 mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 {
@@ -1365,6 +1427,7 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   MpegTSPacketizer2 *packetizer;
   MpegTSPacketizerPacket packet;
   MpegTSBaseClass *klass;
+  static prev_offset;
 
   base = GST_MPEGTS_BASE (parent);
   klass = GST_MPEGTS_BASE_GET_CLASS (base);
@@ -1373,7 +1436,7 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 
   if (klass->input_done)
     gst_buffer_ref (buf);
-
+/*
   if (GST_BUFFER_IS_DISCONT (buf)) {
     GST_DEBUG_OBJECT (base, "Got DISCONT buffer, flushing");
     res = mpegts_base_drain (base);
@@ -1381,9 +1444,9 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
       return res;
 
     mpegts_base_flush (base, FALSE);
-    /* In the case of discontinuities in push-mode with TIME segment
-     * we want to drop all previous observations (hard:TRUE) from
-     * the packetizer */
+    // In the case of discontinuities in push-mode with TIME segment
+    // we want to drop all previous observations (hard:TRUE) from
+    // the packetizer 
     if (base->mode == BASE_MODE_PUSHING
         && base->segment.format == GST_FORMAT_TIME) {
       mpegts_packetizer_flush (base->packetizer, TRUE);
@@ -1391,6 +1454,15 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
     } else
       mpegts_packetizer_flush (base->packetizer, FALSE);
   }
+*/
+  if (GST_BUFFER_OFFSET(buf) < prev_offset) {
+      base->base_offset = prev_offset;
+      GST_DEBUG_OBJECT(base, "New input file, flattening offsets.");
+  }
+  prev_offset = GST_BUFFER_OFFSET_END(buf);
+  
+  GST_BUFFER_OFFSET(buf) += base->base_offset;
+  GST_BUFFER_OFFSET_END(buf) += base->base_offset;
 
   mpegts_packetizer_push (base->packetizer, buf);
 
diff --git a/gst/mpegtsdemux/mpegtsbase.h b/gst/mpegtsdemux/mpegtsbase.h
index 80a454f68..0deb25bb0 100644
--- a/gst/mpegtsdemux/mpegtsbase.h
+++ b/gst/mpegtsdemux/mpegtsbase.h
@@ -32,6 +32,7 @@
 
 #include <gst/gst.h>
 #include "mpegtspacketizer.h"
+#include <gst/mpegts/mpegts.h>
 
 G_BEGIN_DECLS
 
@@ -66,6 +67,8 @@ struct _MpegTSBaseStream
   GstMpegtsPMTStream *stream;
   GstStream          *stream_object;
   gchar              *stream_id;
+  gboolean already_spliced;
+  guint8 cc;
 };
 
 struct _MpegTSBaseProgram
@@ -73,13 +76,15 @@ struct _MpegTSBaseProgram
   gint                program_number;
   guint16             pmt_pid;
   guint16             pcr_pid;
+  guint8              pmt_cc;
+  guint8              pat_cc;
 
   /* Content of the registration descriptor (if present) */
   guint32             registration_id;
 
   GstMpegtsSection   *section;
   const GstMpegtsPMT *pmt;
-
+  GstMpegtsScteSpliceInfo *spliceinfo;
   MpegTSBaseStream  **streams;
   GList              *stream_list;
   gint                patcount;
@@ -125,6 +130,7 @@ struct _MpegTSBase {
   GHashTable *programs;
 
   GPtrArray  *pat;
+  guint16 ts_id;
   MpegTSPacketizer2 *packetizer;
 
   /* arrays that say whether a pid is a known psi pid or a pes pid */
@@ -161,6 +167,8 @@ struct _MpegTSBase {
   /* Whether the parent bin is streams-aware, meaning we can
    * add/remove streams at any point in time */
   gboolean streams_aware;
+
+  guint64 base_offset;
 };
 
 struct _MpegTSBaseClass {
@@ -211,6 +219,9 @@ struct _MpegTSBaseClass {
   void (*nit_info) (GstStructure *nit);
   void (*sdt_info) (GstStructure *sdt);
   void (*eit_info) (GstStructure *eit);
+
+  /* takes ownership of @query */
+  gboolean (*sink_query) (MpegTSBase *base, GstQuery * query);
 };
 
 #define MPEGTS_BIT_SET(field, offs)    ((field)[(offs) >> 3] |=  (1 << ((offs) & 0x7)))
diff --git a/gst/mpegtsdemux/mpegtspacketizer.c b/gst/mpegtsdemux/mpegtspacketizer.c
index cc46ebb25..8465f8743 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.c
+++ b/gst/mpegtsdemux/mpegtspacketizer.c
@@ -45,23 +45,19 @@ G_DEFINE_TYPE_EXTENDED (MpegTSPacketizer2, mpegts_packetizer, G_TYPE_OBJECT, 0,
 
 #define ABSDIFF(a,b) ((a) < (b) ? (b) - (a) : (a) - (b))
 
-#define PACKETIZER_GROUP_LOCK(p) g_mutex_lock(&((p)->group_lock))
-#define PACKETIZER_GROUP_UNLOCK(p) g_mutex_unlock(&((p)->group_lock))
 
 static void mpegts_packetizer_dispose (GObject * object);
 static void mpegts_packetizer_finalize (GObject * object);
-static GstClockTime calculate_skew (MpegTSPacketizer2 * packetizer,
-    MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time);
 static void _close_current_group (MpegTSPCR * pcrtable);
-static void record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
-    guint64 pcr, guint64 offset);
+static void mpegts_packetizer_resync(MpegTSPCR*,GstClockTime,GstClockTime,gboolean);
+//GstClockTime mpegts_packetizer_get_current_time(MpegTSPacketizer2*,guint16);
 
 #define CONTINUITY_UNSET 255
 #define VERSION_NUMBER_UNSET 255
 #define TABLE_ID_UNSET 0xFF
 #define PACKET_SYNC_BYTE 0x47
 
-static inline MpegTSPCR *
+MpegTSPCR *
 get_pcr_table (MpegTSPacketizer2 * packetizer, guint16 pid)
 {
   MpegTSPCR *res;
@@ -175,7 +171,8 @@ seen_section_before (MpegTSPacketizerStream * stream, guint8 table_id,
     return FALSE;
   }
   /* Finally return whether we saw that section or not */
-  return MPEGTS_BIT_IS_SET (subtable->seen_section, section_number);
+//  return MPEGTS_BIT_IS_SET (subtable->seen_section, section_number);
+  return FALSE;
 }
 
 static MpegTSPacketizerStreamSubtable *
@@ -269,6 +266,7 @@ mpegts_packetizer_init (MpegTSPacketizer2 * packetizer)
   packetizer->nb_seen_offsets = 0;
   packetizer->refoffset = -1;
   packetizer->last_in_time = GST_CLOCK_TIME_NONE;
+  packetizer->last_out_time = 0;
   packetizer->pcr_discont_threshold = GST_SECOND;
 }
 
@@ -386,18 +384,57 @@ mpegts_packetizer_parse_adaptation_field_control (MpegTSPacketizer2 *
   /* PCR */
   if (afcflags & MPEGTS_AFC_PCR_FLAG) {
     MpegTSPCR *pcrtable = NULL;
+    GstClockTime prev_out_time=GST_CLOCK_TIME_NONE;
+    GstClockTime curr_out_time;
+
     packet->pcr = mpegts_packetizer_compute_pcr (data);
     data += 6;
-    GST_DEBUG ("pcr 0x%04x %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT
-        ") offset:%" G_GUINT64_FORMAT, packet->pid, packet->pcr,
-        GST_TIME_ARGS (PCRTIME_TO_GSTTIME (packet->pcr)), packet->offset);
-
+    GST_DEBUG_OBJECT (packetizer,"pcr 0x%04x %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT
+        ") offset:%" G_GUINT64_FORMAT " last_out_time:%" GST_TIME_FORMAT,
+        packet->pid,
+        packet->pcr,
+        GST_TIME_ARGS (PCRTIME_TO_GSTTIME (packet->pcr)), 
+        packet->offset,
+        GST_TIME_ARGS(packetizer->last_out_time));
     PACKETIZER_GROUP_LOCK (packetizer);
     if (packetizer->calculate_skew
-        && GST_CLOCK_TIME_IS_VALID (packetizer->last_in_time)) {
-      pcrtable = get_pcr_table (packetizer, packet->pid);
-      calculate_skew (packetizer, pcrtable, packet->pcr,
-          packetizer->last_in_time);
+        && GST_CLOCK_TIME_IS_VALID (packetizer->last_out_time)) {
+        pcrtable = get_pcr_table (packetizer, packet->pid);
+        record_pcr(packetizer, pcrtable, packet->pcr, packet->offset); //pcr:27MHz
+        if(prev_out_time==GST_CLOCK_TIME_NONE){
+//            prev_out_time=packetizer->last_out_time;
+            prev_out_time=pcrtable->base_time;
+        }
+        if(afcflags & 0x80) { //discontinuity
+//          prev_out_time=prev_out_time+(packet->offset-last_offset)*1000;  //Make last packet transmitted with 8mbps????
+          GST_INFO_OBJECT(packetizer,"Resync packetizer due to discontinuity flag. base_time:%"GST_TIME_FORMAT " new PCR:%"GST_TIME_FORMAT,
+            GST_TIME_ARGS(packetizer->last_out_time),
+            GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)));
+ //         mpegts_packetizer_resync(pcrtable,prev_out_time,packet->pcr,TRUE);
+          mpegts_packetizer_resync(pcrtable,packetizer->last_out_time,PCRTIME_TO_GSTTIME(packet->pcr),TRUE);
+          prev_out_time=packetizer->last_out_time;
+        } 
+        curr_out_time=calculate_skew (packetizer, pcrtable, packet->pcr,prev_out_time); //pcr:27MHz
+//        curr_out_time=mpegts_packetizer_pts_to_ts(packetizer,PCRTIME_TO_GSTTIME(packet->pcr),packet->pid);
+        if(curr_out_time==GST_CLOCK_TIME_NONE ||
+            curr_out_time-packetizer->last_out_time>1000000000 || //more than a second jump
+            curr_out_time<packetizer->last_out_time) { //backward jump
+//           mpegts_packetizer_resync(pcrtable,prev_out_time,packet->pcr,TRUE);
+          GST_INFO_OBJECT(packetizer,"Resync packetizer due to gap. base_time:%"GST_TIME_FORMAT " new PCR:%"GST_TIME_FORMAT,
+            GST_TIME_ARGS(packetizer->last_out_time),
+            GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)));
+         //FIXME: We should have a more accurate algorythm here.....
+          mpegts_packetizer_resync(pcrtable,packetizer->last_out_time,PCRTIME_TO_GSTTIME(packet->pcr),TRUE);
+          curr_out_time=packetizer->last_out_time;
+          prev_out_time=curr_out_time;
+        }
+        if(curr_out_time==GST_CLOCK_TIME_NONE) {
+            GST_ERROR_OBJECT(packetizer,"Couldn't get timestamp from PCR, although packetizer was resynced.");
+        } else {
+//            prev_out_time=curr_out_time;
+            packetizer->last_out_time=curr_out_time;
+        }
+//        last_offset=packet->offset;
     }
     if (packetizer->calculate_offset) {
       if (!pcrtable)
@@ -469,8 +506,9 @@ mpegts_packetizer_parse_packet (MpegTSPacketizer2 * packetizer,
 
   packet->scram_afc_cc = tmp = *data++;
   /* transport_scrambling_control 2 */
+  /* FIXME: pass-through scrambled packets.
   if (G_UNLIKELY (tmp & 0xc0))
-    return PACKET_BAD;
+    return PACKET_BAD;   */
 
   packet->data = data;
 
@@ -578,7 +616,7 @@ mpegts_packetizer_clear (MpegTSPacketizer2 * packetizer)
   packetizer->map_data = NULL;
   packetizer->map_size = 0;
   packetizer->map_offset = 0;
-  packetizer->last_in_time = GST_CLOCK_TIME_NONE;
+  packetizer->last_in_time =GST_CLOCK_TIME_NONE;
 
   pcrtable = packetizer->observations[packetizer->pcrtablelut[0x1fff]];
   if (pcrtable)
@@ -618,7 +656,7 @@ mpegts_packetizer_flush (MpegTSPacketizer2 * packetizer, gboolean hard)
   packetizer->map_data = NULL;
   packetizer->map_size = 0;
   packetizer->map_offset = 0;
-  packetizer->last_in_time = GST_CLOCK_TIME_NONE;
+  packetizer->last_in_time =GST_CLOCK_TIME_NONE;
 
   pcrtable = packetizer->observations[packetizer->pcrtablelut[0x1fff]];
   if (pcrtable)
@@ -635,7 +673,7 @@ mpegts_packetizer_flush (MpegTSPacketizer2 * packetizer, gboolean hard)
   PACKETIZER_GROUP_UNLOCK (packetizer);
 
   if (hard) {
-    /* For pull mode seeks in tsdemux the observation must be preserved */
+    /* eFor pull mode seeks in tsdemux the observation must be preserved */
     flush_observations (packetizer);
   }
 }
@@ -665,18 +703,21 @@ mpegts_packetizer_new (void)
 void
 mpegts_packetizer_push (MpegTSPacketizer2 * packetizer, GstBuffer * buffer)
 {
+  GstClockTime ts;
   if (G_UNLIKELY (packetizer->empty)) {
     packetizer->empty = FALSE;
-    packetizer->offset = GST_BUFFER_OFFSET (buffer);
+  //  packetizer->offset = GST_BUFFER_OFFSET (buffer);
   }
 
   GST_DEBUG ("Pushing %" G_GSIZE_FORMAT " byte from offset %"
       G_GUINT64_FORMAT, gst_buffer_get_size (buffer),
       GST_BUFFER_OFFSET (buffer));
   gst_adapter_push (packetizer->adapter, buffer);
-  /* If buffer timestamp is valid, store it */
-  if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_TIMESTAMP (buffer)))
-    packetizer->last_in_time = GST_BUFFER_TIMESTAMP (buffer);
+  /* If the buffer has a valid timestamp, store it - preferring DTS,
+   * which is where upstream arrival times should be stored */
+  ts = GST_BUFFER_DTS_OR_PTS (buffer);
+  if (GST_CLOCK_TIME_IS_VALID (ts))
+    packetizer->last_in_time = ts;
 }
 
 static void
@@ -1086,8 +1127,8 @@ section_start:
   /* Fast path for short packets */
   if (!long_packet) {
     /* We can create the section now (function will check for size) */
-    GST_DEBUG ("Short packet");
-    section_length = (GST_READ_UINT16_BE (data + 1) & 0xfff) + 3;
+   section_length = (GST_READ_UINT16_BE (data + 1) & 0xfff) + 3;
+   GST_DEBUG ("Short packet with length: %i bytes",section_length);
     /* Only do fast-path if we have enough byte */
     if (section_length < packet->data_end - data) {
       if ((section =
@@ -1301,7 +1342,7 @@ mpegts_packetizer_resync (MpegTSPCR * pcr, GstClockTime time,
  *
  * Returns: @time adjusted with the clock skew.
  */
-static GstClockTime
+GstClockTime
 calculate_skew (MpegTSPacketizer2 * packetizer,
     MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time)
 {
@@ -1320,13 +1361,13 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pcr->base_time))) {
     pcr->base_time = time;
     pcr->prev_out_time = GST_CLOCK_TIME_NONE;
-    GST_DEBUG ("Taking new base time %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
+    GST_INFO_OBJECT (packetizer,"Taking new base time %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
   }
 
   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pcr->base_pcrtime))) {
     pcr->base_pcrtime = gstpcrtime;
     pcr->prev_send_diff = -1;
-    GST_DEBUG ("Taking new base pcrtime %" GST_TIME_FORMAT,
+    GST_INFO_OBJECT (packetizer,"Taking new base pcrtime %" GST_TIME_FORMAT,
         GST_TIME_ARGS (gstpcrtime));
   }
 
@@ -1335,7 +1376,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
       gstpcrtime < pcr->last_pcrtime) {
     if (pcr->last_pcrtime - gstpcrtime > PCR_GST_MAX_VALUE / 2) {
       /* PCR wraparound */
-      GST_DEBUG ("PCR wrap");
+      GST_INFO_OBJECT (packetizer,"PCR wrap");
       pcr->pcroffset += PCR_GST_MAX_VALUE;
       gstpcrtime = PCRTIME_TO_GSTTIME (pcrtime) + pcr->pcroffset;
       send_diff = gstpcrtime - pcr->base_pcrtime;
@@ -1343,7 +1384,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
         && pcr->last_pcrtime - gstpcrtime > 15 * GST_SECOND) {
       /* Time jumped backward by > 15 seconds, and we have a timestamp
        * to use to close the discont. Assume a reset */
-      GST_DEBUG ("PCR reset");
+      GST_INFO_OBJECT (packetizer,"PCR reset");
       /* Calculate PCR we would have expected for the given input time,
        * essentially applying the reverse correction process
        *
@@ -1365,7 +1406,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
       pcr->pcroffset += time - pcr->base_time + pcr->base_pcrtime - gstpcrtime;
       gstpcrtime = PCRTIME_TO_GSTTIME (pcrtime) + pcr->pcroffset;
       send_diff = gstpcrtime - pcr->base_pcrtime;
-      GST_DEBUG ("Introduced offset is now %" GST_TIME_FORMAT
+      GST_INFO_OBJECT (packetizer,"Introduced offset is now %" GST_TIME_FORMAT
           " corrected pcr time %" GST_TIME_FORMAT,
           GST_TIME_ARGS (pcr->pcroffset), GST_TIME_ARGS (gstpcrtime));
     } else {
@@ -1389,7 +1430,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
   } else
     send_diff = gstpcrtime - pcr->base_pcrtime;
 
-  GST_DEBUG ("gstpcr %" GST_TIME_FORMAT ", buftime %" GST_TIME_FORMAT
+  GST_DEBUG_OBJECT (packetizer,"gstpcr %" GST_TIME_FORMAT ", buftime %" GST_TIME_FORMAT
       ", base %" GST_TIME_FORMAT ", send_diff %" GST_TIME_FORMAT,
       GST_TIME_ARGS (gstpcrtime), GST_TIME_ARGS (time),
       GST_TIME_ARGS (pcr->base_pcrtime), GST_TIME_ARGS (send_diff));
@@ -1421,7 +1462,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
   slope = recv_diff > 0 ? (send_diff * 8) / recv_diff : 8;
 #endif
 
-  GST_DEBUG ("time %" GST_TIME_FORMAT ", base %" GST_TIME_FORMAT
+  GST_DEBUG_OBJECT (packetizer,"time %" GST_TIME_FORMAT ", base %" GST_TIME_FORMAT
       ", recv_diff %" GST_TIME_FORMAT ", slope %" G_GUINT64_FORMAT,
       GST_TIME_ARGS (time), GST_TIME_ARGS (pcr->base_time),
       GST_TIME_ARGS (recv_diff), slope);
@@ -1430,7 +1471,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
    * changed too quickly we have to resync because the server likely restarted
    * its timestamps. */
   if (ABS (delta - pcr->skew) > packetizer->pcr_discont_threshold) {
-    GST_WARNING ("delta - skew: %" GST_TIME_FORMAT " too big, reset skew",
+    GST_WARNING_OBJECT (packetizer,"delta - skew: %" GST_TIME_FORMAT " too big, reset skew",
         GST_TIME_ARGS (delta - pcr->skew));
     mpegts_packetizer_resync (pcr, time, gstpcrtime, TRUE);
     send_diff = 0;
@@ -1441,7 +1482,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
 
   if (G_UNLIKELY (pcr->window_filling)) {
     /* we are filling the window */
-    GST_DEBUG ("filling %d, delta %" G_GINT64_FORMAT, pos, delta);
+    GST_DEBUG_OBJECT (packetizer,"filling %d, delta %" G_GINT64_FORMAT, pos, delta);
     pcr->window[pos++] = delta;
     /* calc the min delta we observed */
     if (G_UNLIKELY (pos == 1 || delta < pcr->window_min))
@@ -1451,7 +1492,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
       pcr->window_size = pos;
 
       /* window filled */
-      GST_DEBUG ("min %" G_GINT64_FORMAT, pcr->window_min);
+      GST_DEBUG_OBJECT (packetizer,"min %" G_GINT64_FORMAT, pcr->window_min);
 
       /* the skew is now the min */
       pcr->skew = pcr->window_min;
@@ -1502,7 +1543,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
     }
     /* average the min values */
     pcr->skew = (pcr->window_min + (124 * pcr->skew)) / 125;
-    GST_DEBUG ("delta %" G_GINT64_FORMAT ", new min: %" G_GINT64_FORMAT,
+    GST_DEBUG_OBJECT (packetizer,"delta %" G_GINT64_FORMAT ", new min: %" G_GINT64_FORMAT,
         delta, pcr->window_min);
   }
   /* wrap around in the window */
@@ -1535,7 +1576,7 @@ no_skew:
                   && out_time > pcr->prev_out_time) ||
               /* if the server timestamps did not change */
               send_diff == pcr->prev_send_diff)) {
-        GST_DEBUG ("backwards timestamps, using previous time");
+        GST_DEBUG_OBJECT (packetizer,"backwards timestamps, using previous time");
         out_time = GSTTIME_TO_MPEGTIME (out_time);
       }
     }
@@ -1548,7 +1589,7 @@ no_skew:
   pcr->prev_in_time = time;
   pcr->prev_send_diff = send_diff;
 
-  GST_DEBUG ("skew %" G_GINT64_FORMAT ", out %" GST_TIME_FORMAT,
+  GST_DEBUG_OBJECT (packetizer,"skew %" G_GINT64_FORMAT ", out %" GST_TIME_FORMAT,
       pcr->skew, GST_TIME_ARGS (out_time));
 
   return out_time;
@@ -1917,7 +1958,7 @@ _close_current_group (MpegTSPCR * pcrtable)
   /* And re-evaluate all groups */
 }
 
-static void
+void
 record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
     guint64 pcr, guint64 offset)
 {
@@ -1947,34 +1988,34 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
      *    Create a new group with pcr/offset at the right position
      *    Initialize current to that group
      */
-    GST_DEBUG ("No current window estimator, Checking for group to use");
+    GST_DEBUG_OBJECT (packetizer,"No current window estimator, Checking for group to use");
     for (tmp = pcrtable->groups; tmp; tmp = tmp->next) {
       PCROffsetGroup *group = (PCROffsetGroup *) tmp->data;
 
-      GST_DEBUG ("First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT
+      GST_DEBUG_OBJECT (packetizer,"First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT
           " PCR_offset:%" GST_TIME_FORMAT,
           GST_TIME_ARGS (PCRTIME_TO_GSTTIME (group->first_pcr)),
           group->first_offset,
           GST_TIME_ARGS (PCRTIME_TO_GSTTIME (group->pcr_offset)));
-      GST_DEBUG ("Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
+      GST_DEBUG_OBJECT (packetizer,"Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
           GST_TIME_ARGS (PCRTIME_TO_GSTTIME (group->values[group->last_value].
                   pcr)), group->values[group->last_value].offset);
       /* Check if before group */
       if (offset < group->first_offset) {
-        GST_DEBUG ("offset is before that group");
+        GST_DEBUG_OBJECT (packetizer,"offset is before that group");
         break;
       }
       /* Check if within group */
       if (offset <=
           (group->values[group->last_value].offset + group->first_offset)) {
-        GST_DEBUG ("Already observed PCR offset %" G_GUINT64_FORMAT, offset);
+        GST_DEBUG_OBJECT (packetizer,"Already observed PCR offset %" G_GUINT64_FORMAT, offset);
         return;
       }
       /* Check if just after group (i.e. continuation of it) */
       if (!(group->flags & PCR_GROUP_FLAG_CLOSED) &&
           pcr - group->first_pcr - group->values[group->last_value].pcr <=
           100 * PCR_MSECOND) {
-        GST_DEBUG ("Continuation of existing group");
+        GST_DEBUG_OBJECT (packetizer,"Continuation of existing group");
         _use_group (pcrtable, group);
         return;
       }
@@ -1990,15 +2031,15 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
 
   /* FIXME : Detect if we've gone into the next group !
    * FIXME : Close group when that happens */
-  GST_DEBUG ("first:%d, last:%d, write:%d", current->first, current->last,
+  GST_DEBUG_OBJECT (packetizer,"first:%d, last:%d, write:%d", current->first, current->last,
       current->write);
-  GST_DEBUG ("First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT,
+  GST_DEBUG_OBJECT (packetizer,"First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (current->first_pcr)),
       current->first_offset);
-  GST_DEBUG ("Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
+  GST_DEBUG_OBJECT (packetizer,"Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (current->pending[current->last].pcr)),
       current->pending[current->last].offset);
-  GST_DEBUG ("To add (corrected) PCR:%" GST_TIME_FORMAT " offset:%"
+  GST_DEBUG_OBJECT (packetizer,"To add (corrected) PCR:%" GST_TIME_FORMAT " offset:%"
       G_GINT64_FORMAT, GST_TIME_ARGS (PCRTIME_TO_GSTTIME (corpcr)), coroffset);
 
   /* Do we need to close the current group ? */
@@ -2006,8 +2047,8 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
   if (G_UNLIKELY (corpcr < current->pending[current->last].pcr)) {
     /* FIXME : ignore very small deltas (< 500ms ?) which are most likely
      * stray values */
-    GST_DEBUG
-        ("PCR smaller than previously observed one, handling discont/wrapover");
+    GST_DEBUG_OBJECT
+        (packetizer,"PCR smaller than previously observed one, handling discont/wrapover");
     /* Take values from current and put them in the current group (closing it) */
     /* Create new group with new pcr/offset just after the current group
      * and mark it as a wrapover */
@@ -2019,7 +2060,7 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
   /* If PCR diff is greater than 500ms, create new group */
   if (G_UNLIKELY (corpcr - current->pending[current->last].pcr >
           500 * PCR_MSECOND)) {
-    GST_DEBUG ("New PCR more than 500ms away, handling discont");
+    GST_DEBUG_OBJECT (packetizer,"New PCR more than 500ms away, handling discont");
     /* Take values from current and put them in the current group (closing it) */
     /* Create new group with pcr/offset just after the current group
      * and mark it as a discont */
@@ -2030,7 +2071,7 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
   }
 
   if (G_UNLIKELY (corpcr == current->last_value.pcr)) {
-    GST_DEBUG ("Ignoring same PCR (stream is drunk)");
+    GST_DEBUG_OBJECT (packetizer,"Ignoring same PCR (stream is drunk)");
     return;
   }
 
@@ -2041,19 +2082,19 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
   current->last = (current->last + 1) % PCR_BITRATE_NEEDED;
   current->write = (current->write + 1) % PCR_BITRATE_NEEDED;
 
-  GST_DEBUG ("first:%d, last:%d, write:%d", current->first, current->last,
+  GST_DEBUG_OBJECT (packetizer,"first:%d, last:%d, write:%d", current->first, current->last,
       current->write);
-  GST_DEBUG ("First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT,
+  GST_DEBUG_OBJECT (packetizer,"First PCR:%" GST_TIME_FORMAT " offset:%" G_GUINT64_FORMAT,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (current->first_pcr)),
       current->first_offset);
-  GST_DEBUG ("Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
+  GST_DEBUG_OBJECT (packetizer,"Last PCR: +%" GST_TIME_FORMAT " offset: +%" G_GUINT64_FORMAT,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (current->pending[current->last].pcr)),
       current->pending[current->last].offset);
 
   /* If we haven't stored enough values, bail out */
   if (current->write != current->first) {
-    GST_DEBUG
-        ("Not enough observations to calculate bitrate (first:%d, last:%d)",
+    GST_DEBUG_OBJECT
+        (packetizer,"Not enough observations to calculate bitrate (first:%d, last:%d)",
         current->first, current->last);
     return;
   }
@@ -2067,7 +2108,7 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
         current->pending[current->first].offset,
         current->pending[current->last].pcr -
         current->pending[current->first].pcr);
-    GST_DEBUG ("Current bitrate is now %" G_GUINT64_FORMAT,
+    GST_DEBUG_OBJECT (packetizer,"Current bitrate is now %" G_GUINT64_FORMAT,
         current->cur_bitrate);
 
     /* Calculate previous bitrate */
@@ -2075,13 +2116,13 @@ record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
         gst_util_uint64_scale (PCR_SECOND,
         current->pending[current->first].offset - current->prev.offset,
         current->pending[current->first].pcr - current->prev.pcr);
-    GST_DEBUG ("Previous group bitrate now %" G_GUINT64_FORMAT,
+    GST_DEBUG_OBJECT (packetizer,"Previous group bitrate now %" G_GUINT64_FORMAT,
         current->prev_bitrate);
 
     /* FIXME : Better bitrate changes ? Currently 10% changes */
     if (ABSDIFF (current->cur_bitrate,
             current->prev_bitrate) * 10 > current->prev_bitrate) {
-      GST_DEBUG ("Current bitrate changed by more than 10%% (old:%"
+      GST_DEBUG_OBJECT (packetizer,"Current bitrate changed by more than 10%% (old:%"
           G_GUINT64_FORMAT " new:%" G_GUINT64_FORMAT ")", current->prev_bitrate,
           current->cur_bitrate);
       /* If we detected a change in bitrate, this means that
@@ -2215,8 +2256,8 @@ mpegts_packetizer_pts_to_ts (MpegTSPacketizer2 * packetizer,
   pcrtable = get_pcr_table (packetizer, pcr_pid);
 
   if (!GST_CLOCK_TIME_IS_VALID (pcrtable->base_time) && pcr_pid == 0x1fff &&
-      GST_CLOCK_TIME_IS_VALID (packetizer->last_in_time)) {
-    pcrtable->base_time = packetizer->last_in_time;
+      GST_CLOCK_TIME_IS_VALID (packetizer->last_out_time)) {
+    pcrtable->base_time = packetizer->last_out_time;
     pcrtable->base_pcrtime = pts;
   }
 
@@ -2242,7 +2283,7 @@ mpegts_packetizer_pts_to_ts (MpegTSPacketizer2 * packetizer,
       res = GST_CLOCK_TIME_NONE;
     else {
       GstClockTime tmp = pcrtable->base_time + pcrtable->skew;
-      if (tmp + res > pcrtable->base_pcrtime)
+      if (tmp + res >= pcrtable->base_pcrtime)
         res += tmp - pcrtable->base_pcrtime;
       else
         res = GST_CLOCK_TIME_NONE;
diff --git a/gst/mpegtsdemux/mpegtspacketizer.h b/gst/mpegtsdemux/mpegtspacketizer.h
index 0cf83a60d..bc5b9e830 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.h
+++ b/gst/mpegtsdemux/mpegtspacketizer.h
@@ -275,8 +275,10 @@ struct _MpegTSPacketizer2 {
   /* Number of seen pcr/offset observations (FIXME : kill later) */
   guint nb_seen_offsets;
 
-  /* Last inputted timestamp */
+  /* Last inputted/outputted timestamp */
   GstClockTime last_in_time;
+  GstClockTime last_out_time;
+  GstClockTime last_base_time; //base time set due to discointinuity
 
   /* offset to observations table */
   guint8 pcrtablelut[0x2000];
@@ -328,6 +330,15 @@ typedef struct
 #define MPEGTS_BIT_SET(field, offs)    ((field)[(offs) >> 3] |=  (1 << ((offs) & 0x7)))
 #define MPEGTS_BIT_UNSET(field, offs)  ((field)[(offs) >> 3] &= ~(1 << ((offs) & 0x7)))
 #define MPEGTS_BIT_IS_SET(field, offs) ((field)[(offs) >> 3] &   (1 << ((offs) & 0x7)))
+#define PACKETIZER_GROUP_LOCK(p) g_mutex_lock(&((p)->group_lock))
+#define PACKETIZER_GROUP_UNLOCK(p) g_mutex_unlock(&((p)->group_lock))
+
+GstClockTime calculate_skew(MpegTSPacketizer2 * packetizer,
+    MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time);
+void record_pcr(MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
+    guint64 pcr, guint64 offset);
+MpegTSPCR *
+get_pcr_table(MpegTSPacketizer2 * packetizer, guint16 pid);
 
 typedef enum {
   PACKET_BAD       = FALSE,
diff --git a/gst/mpegtsdemux/mpegtsparse.c b/gst/mpegtsdemux/mpegtsparse.c
index 8e227baad..6d5fe2b8b 100644
--- a/gst/mpegtsdemux/mpegtsparse.c
+++ b/gst/mpegtsdemux/mpegtsparse.c
@@ -1,4 +1,4 @@
-/*
+ /*
  * mpegtsparse.c - 
  * Copyright (C) 2007 Alessandro Decina
  * 
@@ -33,6 +33,8 @@
 #include "mpegtsbase.h"
 #include "mpegtsparse.h"
 #include "gstmpegdesc.h"
+#include "pesparse.h"
+#include <gst/video/video.h>
 
 /* latency in mseconds is maximum 100 ms between PCR */
 #define TS_LATENCY 100
@@ -45,6 +47,41 @@ GST_DEBUG_CATEGORY_STATIC (mpegts_parse_debug);
 
 typedef struct _MpegTSParsePad MpegTSParsePad;
 
+static guint8 unham84tab[256] = {
+    0x01, 0xff, 0x01, 0x01, 0xff, 0x00, 0x01, 0xff,
+    0xff, 0x02, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x07,
+    0xff, 0x00, 0x01, 0xff, 0x00, 0x80, 0xff, 0x00,
+    0x06, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x03, 0xff,
+    0xff, 0x0c, 0x01, 0xff, 0x04, 0xff, 0xff, 0x07,
+    0x06, 0xff, 0xff, 0x07, 0xff, 0x07, 0x07, 0x87,
+    0x06, 0xff, 0xff, 0x05, 0xff, 0x00, 0x0d, 0xff,
+    0x86, 0x06, 0x06, 0xff, 0x06, 0xff, 0xff, 0x07,
+    0xff, 0x02, 0x01, 0xff, 0x04, 0xff, 0xff, 0x09,
+    0x02, 0x82, 0xff, 0x02, 0xff, 0x02, 0x03, 0xff,
+    0x08, 0xff, 0xff, 0x05, 0xff, 0x00, 0x03, 0xff,
+    0xff, 0x02, 0x03, 0xff, 0x03, 0xff, 0x83, 0x03,
+    0x04, 0xff, 0xff, 0x05, 0x84, 0x04, 0x04, 0xff,
+    0xff, 0x02, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x07,
+    0xff, 0x05, 0x05, 0x85, 0x04, 0xff, 0xff, 0x05,
+    0x06, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x03, 0xff,
+    0xff, 0x0c, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x09,
+    0x0a, 0xff, 0xff, 0x0b, 0x8a, 0x0a, 0x0a, 0xff,
+    0x08, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x0d, 0xff,
+    0xff, 0x0b, 0x0b, 0x8b, 0x0a, 0xff, 0xff, 0x0b,
+    0x0c, 0x8c, 0xff, 0x0c, 0xff, 0x0c, 0x0d, 0xff,
+    0xff, 0x0c, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x07,
+    0xff, 0x0c, 0x0d, 0xff, 0x0d, 0xff, 0x8d, 0x0d,
+    0x06, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x0d, 0xff,
+    0x08, 0xff, 0xff, 0x09, 0xff, 0x09, 0x09, 0x89,
+    0xff, 0x02, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x09,
+    0x88, 0x08, 0x08, 0xff, 0x08, 0xff, 0xff, 0x09,
+    0x08, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x03, 0xff,
+    0xff, 0x0c, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x09,
+    0x0f, 0xff, 0x8f, 0x0f, 0xff, 0x0e, 0x0f, 0xff,
+    0x08, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x0d, 0xff,
+    0xff, 0x0e, 0x0f, 0xff, 0x0e, 0x8e, 0xff, 0x0e,
+};
+
 typedef struct
 {
   MpegTSBaseProgram program;
@@ -58,12 +95,22 @@ struct _MpegTSParsePad
   /* the program number that the peer wants on this pad */
   gint program_number;
   MpegTSParseProgram *program;
+  GstClockTime last_splice_ts;
 
   /* set to FALSE before a push and TRUE after */
   gboolean pushed;
 
   /* the return of the latest push */
   GstFlowReturn flow_return;
+
+  GstBuffer *pending_packets;
+  GstBuffer *spliced_packets;
+  gboolean has_pat, has_pmt;
+  gboolean splicing_inprogress;
+  GstMemory *pat, *pmt;
+  guint64 min_pts,max_pts,first_pcr,last_pcr;
+  guint64 video_frame_duration; //Duration of a video frame. Used for calculating the end of a video frame if PTS is known.
+  GstClockTime next_pcr;  // PCR value of the packet after the splicing point. Appended in an empty video packet to the end of the regional segment.
 };
 
 static GstStaticPadTemplate src_template =
@@ -84,6 +131,7 @@ enum
   PROP_SET_TIMESTAMPS,
   PROP_SMOOTHING_LATENCY,
   PROP_PCR_PID,
+  PROP_SCTE35_INSERT
   /* FILL ME */
 };
 
@@ -115,6 +163,8 @@ static void mpegts_parse_release_pad (GstElement * element, GstPad * pad);
 static gboolean mpegts_parse_src_pad_query (GstPad * pad, GstObject * parent,
     GstQuery * query);
 static gboolean push_event (MpegTSBase * base, GstEvent * event);
+gboolean mpegts_parse_tspad_all_streams_spliced(MpegTSParsePad*, guint16);
+gboolean mpegts_parse_tspad_pid_spliced(MpegTSParsePad*, guint16);
 
 #define mpegts_parse_parent_class parent_class
 G_DEFINE_TYPE (MpegTSParse2, mpegts_parse, GST_TYPE_MPEGTS_BASE);
@@ -159,6 +209,10 @@ mpegts_parse_class_init (MpegTSParse2Class * klass)
       g_param_spec_int ("pcr-pid", "PID containing PCR",
           "Set the PID to use for PCR values (-1 for auto)",
           -1, G_MAXINT, -1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property(gobject_class, PROP_SCTE35_INSERT,
+      g_param_spec_boxed("scte35-insert", "SCTE35 insert",
+          "A GstStructure to set an SCTE35 Insert command", GST_TYPE_STRUCTURE,
+          G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
 
   element_class = GST_ELEMENT_CLASS (klass);
   element_class->pad_removed = mpegts_parse_pad_removed;
@@ -169,7 +223,7 @@ mpegts_parse_class_init (MpegTSParse2Class * klass)
   gst_element_class_add_static_pad_template (element_class, &program_template);
 
   gst_element_class_set_static_metadata (element_class,
-      "MPEG transport stream parser", "Codec/Parser",
+      "MPEG transport stream parser - with duration", "Codec/Parser",
       "Parses MPEG2 transport streams",
       "Alessandro Decina <alessandro@nnva.org>, "
       "Zaheer Abbas Merali <zaheerabbas at merali dot org>");
@@ -270,6 +324,23 @@ mpegts_parse_set_property (GObject * object, guint prop_id,
     case PROP_PCR_PID:
       parse->pcr_pid = parse->user_pcr_pid = g_value_get_int (value);
       break;
+    case PROP_SCTE35_INSERT: {
+        const GstStructure *s = gst_value_get_structure(value);
+        guint program_number;
+        MpegTSBaseProgram *program;
+
+        gst_structure_get_uint(s, "program-number", &program_number);
+        program = mpegts_base_get_program(&parse->parent, program_number);
+
+        if (program->spliceinfo != NULL) {
+            g_slice_free(GstMpegtsScteSpliceInfo, program->spliceinfo);
+            program->spliceinfo = NULL; // FIXME: We probably need a better code to free the allocated memory!!!
+        }
+        program->spliceinfo = gst_mpegts_set_scte_splice_info(s);
+        GST_DEBUG_OBJECT(parse, "Splice insert created from stucture.");
+        break;
+    }
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
   }
@@ -389,7 +460,31 @@ push_event (MpegTSBase * base, GstEvent * event)
 
   return TRUE;
 }
-
+static gboolean 
+mpegts_parse_srcpad_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    gboolean res = TRUE;
+    MpegTSParse2 *parse = GST_MPEGTS_PARSE(parent);
+    GST_LOG_OBJECT(parse, "Got event %s",
+        gst_event_type_get_name(GST_EVENT_TYPE(event)));
+
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_CUSTOM_UPSTREAM:
+        if (gst_video_event_is_force_key_unit(event)) {
+            GstClockTime timestamp, stream_time, running_time;
+            gboolean all_headers;
+            guint count;
+            gst_video_event_parse_upstream_force_key_unit(event, &running_time, &all_headers, &count);
+            GST_INFO_OBJECT(parse, "received upstream force key unit event, "
+                "seqnum %d running_time %" GST_TIME_FORMAT
+                " all_headers %d count %d", gst_event_get_seqnum(event),
+                GST_TIME_ARGS(running_time), all_headers, count);
+        }
+    default:
+        res = gst_pad_event_default(pad, parent, event);
+    }
+    return res;
+}
 static MpegTSParsePad *
 mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
 {
@@ -399,6 +494,8 @@ mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
   pad = gst_pad_new_from_static_template (&program_template, pad_name);
   gst_pad_set_query_function (pad,
       GST_DEBUG_FUNCPTR (mpegts_parse_src_pad_query));
+  gst_pad_set_event_function(pad,
+      GST_DEBUG_FUNCPTR(mpegts_parse_srcpad_event));
 
   /* create our wrapper */
   tspad = g_new0 (MpegTSParsePad, 1);
@@ -407,9 +504,16 @@ mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
   tspad->program = NULL;
   tspad->pushed = FALSE;
   tspad->flow_return = GST_FLOW_NOT_LINKED;
+  tspad->pending_packets = NULL;
+  tspad->spliced_packets = NULL;
+  tspad->has_pat = FALSE;
+  tspad->has_pmt = FALSE;
+  tspad->splicing_inprogress = FALSE;
+  tspad->last_splice_ts = GST_CLOCK_TIME_NONE;
+  tspad->video_frame_duration=90000*0.02; //FIXME: Should depend on encoding. MPEG2 uses 40ms, MPEG4 20ms. 
   gst_pad_set_element_private (pad, tspad);
   gst_flow_combiner_add_pad (parse->flowcombiner, pad);
-
+  
   return tspad;
 }
 
@@ -457,6 +561,7 @@ mpegts_parse_request_new_pad (GstElement * element, GstPadTemplate * template,
   gint program_num = -1;
   GstEvent *event;
   gchar *stream_id;
+  GstSegment seg;
 
   g_return_val_if_fail (template != NULL, NULL);
   g_return_val_if_fail (GST_IS_MPEGTS_PARSE (element), NULL);
@@ -507,6 +612,11 @@ mpegts_parse_request_new_pad (GstElement * element, GstPadTemplate * template,
     gst_event_set_group_id (event, parse->group_id);
 
   gst_pad_push_event (pad, event);
+
+  gst_segment_init(&seg, GST_FORMAT_TIME);
+  GST_DEBUG_OBJECT(parse,
+      "Generating time output segment %" GST_SEGMENT_FORMAT, &seg);
+  gst_pad_push_event(pad, gst_event_new_segment(&seg));
   g_free (stream_id);
 
   gst_element_add_pad (element, pad);
@@ -525,6 +635,625 @@ mpegts_parse_release_pad (GstElement * element, GstPad * pad)
   gst_element_remove_pad (element, pad);
 }
 
+gboolean
+mpegts_parse_tspad_pid_spliced(MpegTSParsePad *tspad, guint16 pid)
+{
+    if (tspad->program->program.streams[pid] == NULL)
+        return TRUE;
+    switch (tspad->program->program.streams[pid]->stream_type) {
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG1:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG1:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG2:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_H264:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_CLEAN:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC:
+        return tspad->program->program.streams[pid]->already_spliced;
+    default:
+        return TRUE;
+    }
+}
+
+gboolean
+mpegts_parse_tspad_all_streams_spliced(MpegTSParsePad *tspad, guint16 pid)
+{
+    GList *s;
+    gboolean res = TRUE;
+    if(tspad->program->program.stream_list == NULL)
+        return FALSE;
+    for (s = tspad->program->program.stream_list; s != NULL; s = s->next) {
+        MpegTSBaseStream *stream = (MpegTSBaseStream*)s->data;
+        switch (stream->stream_type) {
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG1:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG1:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG2:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_H264:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_CLEAN:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC:
+            res &=stream->already_spliced;
+        }
+    }
+    return res;
+}
+
+static void
+stream_clear_spliced_flag(MpegTSBaseStream *stream, gpointer user_data)
+{
+    stream->already_spliced = FALSE;
+}
+
+static gboolean
+set_packet_discontinuity_flag(MpegTSParse2 *parse, MpegTSPacketizerPacket *packet) 
+{
+    if (packet->scram_afc_cc & 0x20) {
+        //FIXME:If adaptation field length is 0; this will fail!!!
+        GST_DEBUG_OBJECT(parse, "Setting packet discountinuity flag to 1 on PID:%04x.",packet->pid);
+        packet->data_start[5] |= 0x80;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static gboolean
+set_packet_cc(MpegTSParse2 * parse, MpegTSParsePad *tspad, MpegTSPacketizerPacket *packet)
+{
+    if (tspad->program != NULL) {
+        if (tspad->program->program.streams[packet->pid] != NULL && MPEGTS_BIT_IS_SET(parse->parent.is_pes, packet->pid)) {
+            packet->scram_afc_cc &= 0xf0;
+            if (((packet->scram_afc_cc & 0x30 )== 0) || ((packet->scram_afc_cc & 0x30) == 0x20)) {
+                packet->scram_afc_cc |= tspad->program->program.streams[packet->pid]->cc % 16;
+                GST_LOG_OBJECT(parse, "PID:%i AFC:0x%x CC not increased.", packet->pid, packet->scram_afc_cc);
+            }
+            else {
+                packet->scram_afc_cc |= ++tspad->program->program.streams[packet->pid]->cc % 16;
+            }
+            packet->data_start[3] = packet->scram_afc_cc;
+            GST_LOG_OBJECT(parse, "Increase CC for PID:0x%0x in Stream:%s", packet->pid, tspad->program->program.streams[packet->pid]->stream_id);
+            return TRUE;
+        } else if (packet->pid == 0) {
+            packet->scram_afc_cc &= 0xf0;
+            packet->scram_afc_cc |= ++tspad->program->program.pat_cc % 16;
+            packet->data_start[3] = packet->scram_afc_cc;
+        }
+        else if (packet->pid == tspad->program->program.pmt_pid) {
+            packet->scram_afc_cc &= 0xf0;
+            packet->scram_afc_cc |= ++tspad->program->program.pmt_cc % 16;
+            packet->data_start[3] = packet->scram_afc_cc;
+        }
+    }
+    return FALSE;
+}
+
+static void
+mpegts_parse_tspad_insert_adaptation_field_with_discontinuity_flag(MpegTSParse2 *parse, MpegTSParsePad *tspad, guint16 pid,GstBuffer *buf) {
+    GstMemory *mem = gst_allocator_alloc(NULL, 188, NULL);
+    GstMapInfo info;
+    gst_memory_map(mem, &info, GST_MAP_WRITE);
+    memset(info.data, 0xff, 188);
+    info.data[0] = 0x47;
+    info.data[1] = (pid & 0x1fff) >> 8;
+    info.data[2] = (pid & 0x00ff);
+    info.data[3] = 0x20 | (tspad->program->program.streams[pid]->cc % 16);
+    info.data[4] = 188 - 5;
+    info.data[5] = 0x80;
+    gst_memory_unmap(mem, &info);
+    gst_buffer_append_memory(buf, mem);
+    GST_DEBUG_OBJECT(parse, "Adaptation only packet for PID:%i is appended with discountinuity flag.", pid);
+}
+
+
+//new_pcr is in nanoseconds!!!!!!
+static void
+mpegts_parse_tspad_insert_adaptation_field_with_pcr(MpegTSParse2 *parse, MpegTSParsePad *tspad, guint16 pid,GstClockTime new_pcr, GstBuffer *buf) {
+    GstMemory *mem = gst_allocator_alloc(NULL, 188, NULL);
+    GstMapInfo info;
+    guint64 pcr_base;
+    guint16 pcr_ext;
+
+    gst_memory_map(mem, &info, GST_MAP_WRITE);
+    memset(info.data, 0xff, 188);
+    info.data[0] = 0x47;
+    info.data[1] = (pid & 0x1fff) >> 8;
+    info.data[2] = (pid & 0x00ff);
+    info.data[3] = 0x20 | (tspad->program->program.streams[pid]->cc % 16);
+    info.data[4] = 188 - 5;
+    info.data[5] = 0x10;
+    pcr_base = (GSTTIME_TO_PCRTIME(new_pcr)/300)&0x1ffffffff; //truncate to 33 bits
+    pcr_ext = GSTTIME_TO_PCRTIME(new_pcr)%300;
+    GST_WRITE_UINT32_BE(info.data+6,pcr_base>>1); 
+    GST_WRITE_UINT16_BE(info.data+10,((pcr_base&0x1)<<15)|(pcr_ext&0x1ff));
+
+    gst_memory_unmap(mem, &info);
+    gst_buffer_append_memory(buf, mem);
+    GST_DEBUG_OBJECT(parse, "Adaptation only packet for PID:%i is appended with PCR:%."GST_TIME_FORMAT, 
+        pid,GST_TIME_ARGS(new_pcr));
+}
+
+static void
+set_packet_pcr(MpegTSPacketizerPacket *packet,GstClockTime new_pcr)
+// new_pcr value is in ns
+{
+    guint64 pcr_base;
+    guint16 pcr_ext;
+
+    pcr_base = (GSTTIME_TO_PCRTIME(new_pcr)/300)&0x1ffffffff; //truncate to 33 bits
+    pcr_ext = GSTTIME_TO_PCRTIME(new_pcr)%300;
+    GST_WRITE_UINT32_BE(packet->data_start+6,pcr_base>>1); 
+    GST_WRITE_UINT16_BE(packet->data_start+10,((pcr_base&0x1)<<15)|(pcr_ext&0x1ff));
+}
+
+static inline guint64
+mpegts_packetizer_compute_pcr (const guint8 * data)
+{
+   guint32 pcr1;
+   guint16 pcr2;
+   guint64 pcr, pcr_ext;
+ 
+   pcr1 = GST_READ_UINT32_BE (data);
+   pcr2 = GST_READ_UINT16_BE (data + 4);
+   pcr = ((guint64) pcr1) << 1;
+   pcr |= (pcr2 & 0x8000) >> 15;
+   pcr_ext = (pcr2 & 0x01ff);
+   return pcr * 300 + pcr_ext % 300;
+}
+
+static GstFlowReturn
+mpegts_parse_tspad_queue_packet(MpegTSParse2 * parse, MpegTSParsePad * 
+    tspad, MpegTSPacketizerPacket * packet, GstMpegtsSection * section)
+{
+    GstFlowReturn ret = GST_FLOW_OK;
+    PESParsingResult pesparsing_res=PES_PARSING_BAD;
+    GstMapInfo info;
+//    MpegTSPacketizerStream *stream;
+    PESHeader pes;
+    gboolean ad_hoc_splice = FALSE;
+    gboolean all_streams_spliced = FALSE;
+    GstBuffer *actual_buffer;
+    guint16 splice_event_id;
+    static gint8 splice_event_index;
+    GstMemory *mem = gst_allocator_alloc(NULL, packet->data_end - packet->data_start, NULL);
+
+
+    GstClockTime current_timestamp = GST_CLOCK_TIME_NONE;
+    guint8* txt_payload;
+
+    GST_LOG_OBJECT(parse, "Program:%i PID:0x%04x afc:0x%04x, pusi:%i, size:%li", 
+        tspad->program_number, packet->pid, packet->scram_afc_cc,
+        packet->payload_unit_start_indicator,packet->data_end-packet->data_start);
+
+    if( packet->payload_unit_start_indicator && MPEGTS_BIT_IS_SET(parse->parent.is_pes,packet->pid)) {
+        //Get PES header from packet
+        pesparsing_res=mpegts_parse_pes_header(packet->payload,packet->data_end-packet->payload,&pes);
+        if(pesparsing_res==PES_PARSING_OK) {
+          GST_LOG_OBJECT(parse,"PES header parsed successfully from pid:0x%04x PTS:%"GST_TIME_FORMAT,
+            packet->pid,GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+        } else if(pesparsing_res==PES_PARSING_NEED_MORE) {
+            GST_ERROR_OBJECT(parse,"PES Header couldn't be parsed for pid:0x%04x. Need more data.",packet->pid);
+        } else {
+            GST_ERROR_OBJECT(parse,"PES Header parsing failed for pid:0x%04x",packet->pid);
+        }
+    }
+
+    /* Search for X31 teletext packets */
+    if (parse->parent.parse_private_sections && MPEGTS_BIT_IS_SET(parse->parent.is_pes, packet->pid)) {
+        if (tspad->program->program.streams[packet->pid]->stream_type == GST_MPEGTS_STREAM_TYPE_PRIVATE_PES_PACKETS) {
+            if (packet->payload_unit_start_indicator) {
+                if (pesparsing_res == PES_PARSING_OK) {
+                    txt_payload = packet->payload + pes.header_size;
+                    GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i header length:%i data_identifier:%x",
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), pes.packet_length, pes.header_size, *txt_payload);
+                    if (*txt_payload++ >= 0x10 ) { //data_identifier: EBU data EN 300 472 (teletext)/EN 301 775; next byte:data_unit_id
+                        GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i data_unit_id:0x%x",
+                            GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), *(txt_payload+1),*txt_payload);
+                        while (txt_payload < packet->data_end) {
+                            if (*txt_payload == 0x02 || *txt_payload == 0x03) { //data_unit_id: EBU Teletext non-subtitle data or subtitle data
+                                guint8 c1, c2, c;
+                                guint8 magazine, packet_nr;
+                                static guint gpis;
+                                c1 = unham84tab[*(txt_payload+4)];
+                                c2 = unham84tab[*(txt_payload+5)];
+                                c = (c2 << 4) | (c1 & 0x0f);
+                                packet_nr = (c >> 3) & 0x1f;
+                                magazine = c & 0x07;
+                                GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i data_unit_id:%x packet:0x%0x magazine:0x%0x",
+                                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), *(txt_payload + 1), *txt_payload,packet_nr,magazine);
+                                if (packet_nr == 31) { //We have an X31 packet!!!!
+                                    if (*(txt_payload+11) != gpis) {
+                                        GstEvent *x31event;
+                                        gpis = *(txt_payload+11);
+                                        GST_INFO_OBJECT(parse, "X31 packet detected at %" GST_TIME_FORMAT " with different GPIs:0x%x",
+                                            GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), gpis);
+                                        gst_element_post_message(GST_ELEMENT(&parse->parent.element),
+                                            gst_message_new_element(GST_OBJECT(&parse->parent.element),
+                                                gst_structure_new("x31-received",
+                                                    "PTS", G_TYPE_UINT64, pes.PTS,
+                                                    "GPI", G_TYPE_UINT, gpis, NULL)));
+                                        x31event = gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM,
+                                            gst_structure_new("x31-received",
+                                                "PTS", G_TYPE_UINT64, pes.PTS,
+                                                "GPI", G_TYPE_UINT, gpis, NULL));
+                                        gst_pad_push_event(tspad->pad, x31event);
+
+                                    }
+                                    GST_LOG_OBJECT(parse, "X31 packet detected at %" GST_TIME_FORMAT " with GPI:0x%x native: 0x%0x 0x%0x",
+                                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)),c,*(txt_payload+11),*(txt_payload+12));
+                                }
+
+                            } else {
+                                GST_LOG_OBJECT(parse, "Non-teletext packet detected in teletext pid.");
+                            }
+                            txt_payload += *(txt_payload+1)+1; //Move to the next txt data block in the TS packet payload
+                        }
+                    }
+                } else {
+                    GST_ERROR_OBJECT(parse,"Couldn't decode PES header in teletext packet. (res:%i) X31 cannot be detected.",pesparsing_res);
+                }
+            }
+        }
+    }
+    //FIXME Here we handle the discontinuity
+    if (packet->afc_flags & 0x10) {
+        //Have a PCR in the packet, let's convert it to buffer timestamp.
+        current_timestamp = mpegts_packetizer_pts_to_ts(parse->parent.packetizer,PCRTIME_TO_GSTTIME(packet->pcr),packet->pid);
+        if(current_timestamp==GST_CLOCK_TIME_NONE) {
+          MpegTSPacketizer2 *packetizer=parse->parent.packetizer; 
+          GST_ERROR_OBJECT(parse,"Couldn't get timestamp from PCR. Bytes from last PCR:%u ",parse->bytes_since_pcr);
+          // This is bad, we have a PCR in the packet but we cannot convert it to a timestamp...
+          // Let's increase the log level and try again....
+          gst_debug_set_threshold_for_name("mpegtspacketizer",GST_LEVEL_DEBUG);
+          GST_DEBUG_OBJECT (parse,"pcr 0x%04x %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT ") offset:%" G_GUINT64_FORMAT " last_in_time:%" GST_TIME_FORMAT, 
+                packet->pid, packet->pcr,GST_TIME_ARGS (PCRTIME_TO_GSTTIME (packet->pcr)), packet->offset,GST_TIME_ARGS(packetizer->last_in_time));
+          current_timestamp = mpegts_packetizer_pts_to_ts(parse->parent.packetizer,PCRTIME_TO_GSTTIME(packet->pcr),packet->pid);
+          if(current_timestamp==GST_CLOCK_TIME_NONE) {
+            //Send an error to the pipeline that normally quits the mainloop.
+            GST_ELEMENT_ERROR(GST_ELEMENT_CAST(parse),STREAM,FAILED,(NULL),("Couldn't get timestamp from PCR.")); 
+          }
+          gst_debug_set_threshold_for_name("mpegtspacketizer",GST_LEVEL_WARNING);
+       } else { // We have a valid timestamp. Should be the norma case.
+         parse->parent.packetizer->last_out_time=current_timestamp;
+       }
+       if ((packet->afc_flags & 0x80) && GST_BUFFER_PTS_IS_VALID(tspad->pending_packets)) { 
+            //FIXME: We have discontinuity flag set and this is a video(pcr) packet.
+            //current_timestamp= GST_BUFFER_PTS(tspad->pending_packets) + (parse->bytes_since_pcr*8/4000000)*1000000000;
+            if (pesparsing_res == PES_PARSING_OK) {
+                GstClockTime pcr_2,ideal_pcr_0;
+                gint64 pcr_diff; 
+                if(pes.DTS!=GST_CLOCK_TIME_NONE) {
+                    //Have a DTS, lets assume that first packet is 2 frames back
+                    //pcr_2=pes.PTS-(90000*0.08); //90kHz*80ms -- duration of 2 frames
+                    pcr_2=pes.DTS;
+                } else {
+                    pcr_2=pes.PTS; //We just have I and P frames, PTS is monoton increasing
+                }
+                GST_DEBUG_OBJECT(parse,"Discontinuity detected. PCR1 %" GST_TIME_FORMAT " PCR3 %" GST_TIME_FORMAT " PCR_0 %" GST_TIME_FORMAT " PCR_2 %" GST_TIME_FORMAT ,
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(tspad->last_pcr)),
+                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->max_pts)),
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pcr_2)));
+                ideal_pcr_0=MPEGTIME_TO_GSTTIME(pcr_2)-(MPEGTIME_TO_GSTTIME(tspad->max_pts+tspad->video_frame_duration)-PCRTIME_TO_GSTTIME(tspad->last_pcr));
+                pcr_diff=PCRTIME_TO_GSTTIME(packet->pcr)-PCRTIME_TO_GSTTIME(ideal_pcr_0);
+                GST_DEBUG_OBJECT(parse,"New fragment starting with PCR: %" GST_TIME_FORMAT ", ideal PCR: %" GST_TIME_FORMAT " difference:%"G_GINT64_FORMAT " ms.",
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                    GST_TIME_ARGS(ideal_pcr_0),
+                    pcr_diff/1000000);
+                //Ignore PCR adjustment for now....
+                //set_packet_pcr(packet,ideal_pcr_0);
+                packet->pcr=mpegts_packetizer_compute_pcr(packet->data_start+6);
+                GST_DEBUG_OBJECT(parse,"Packet PCR has been changed to %"GST_TIME_FORMAT,GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)));
+            } else {
+                GST_ERROR_OBJECT(parse,"Discontinuity detected but couldn't parse PES header.");
+            }
+        }
+        GST_LOG_OBJECT(parse,"PCR:%"GST_TIME_FORMAT " current_timestamp:%"GST_TIME_FORMAT,
+            GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+            GST_TIME_ARGS(current_timestamp));
+    }
+
+    if ((packet->afc_flags & 0x10) && (tspad->last_splice_ts==GST_CLOCK_TIME_NONE)) { 
+        //packet has PCR and probably the first PCR we found. Send segment event.
+        GstSegment seg;
+        gst_segment_init(&seg, GST_FORMAT_TIME);
+        if(GST_CLOCK_TIME_IS_VALID(current_timestamp)) {
+            tspad->last_splice_ts=current_timestamp;
+            seg.start=current_timestamp;
+            if(tspad->pending_packets!=NULL) {
+                GST_BUFFER_PTS(tspad->pending_packets)=current_timestamp;
+            }
+        } else{
+            tspad->last_splice_ts = 0;
+            current_timestamp=0;
+            seg.start = 0;
+        }
+        GST_INFO_OBJECT(parse,
+            "First packet. Generating time output segment %" GST_SEGMENT_FORMAT, &seg);
+        gst_pad_push_event(tspad->pad, gst_event_new_segment(&seg));
+
+    }
+
+    if (tspad->splicing_inprogress == TRUE) {
+        if (mpegts_parse_tspad_pid_spliced(tspad, packet->pid)==FALSE && packet->payload_unit_start_indicator==64) {
+            if (pesparsing_res == PES_PARSING_OK) {
+                GST_DEBUG_OBJECT(parse, "PES header parsed with result PES_PARSING_OK; PID:0x%04x, PTS:%" GST_TIME_FORMAT, packet->pid,GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+                if (tspad->program->program.spliceinfo != NULL) {
+                    GST_DEBUG_OBJECT(parse, "Splice event exists. PTS:%"GST_TIME_FORMAT " Offset:%" GST_TIME_FORMAT,
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->splice_insert.pts_time)),
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->pts_adjustment)));
+                    if (tspad->program->program.spliceinfo->splice_insert.pts_time < pes.PTS) {
+                        tspad->program->program.streams[packet->pid]->already_spliced = TRUE;
+                        //Audio packets doesn't have adaptation field even at audio frame boundaries. Let's insert a full packet.
+                        mpegts_parse_tspad_insert_adaptation_field_with_discontinuity_flag(parse, tspad, packet->pid, tspad->spliced_packets);
+
+                    }
+                }
+            }
+            else {
+                GST_WARNING_OBJECT(parse, "Failed to parse PES header for PID:%i", packet->pid);
+            }
+        }
+    }
+
+    if ((packet->afc_flags & 0x40) && (packet->afc_flags & 0x10) && (tspad->pending_packets != NULL) && 
+        tspad->splicing_inprogress==FALSE && parse->parent.parse_private_sections==TRUE) {
+        //random access and PCR bits are set; Either push out buffer or initiate splicing...
+        if (tspad->splicing_inprogress == TRUE) {
+            GST_WARNING_OBJECT(parse, "New packet with random access, although splicing is already in progress. Shouldn't happen!!!!");
+        }
+        //Check if we have a splice event scheduled
+        if (tspad->program->program.spliceinfo != NULL) {
+             GST_DEBUG_OBJECT(parse, "Splice event exists. PTS:%"GST_TIME_FORMAT " Offset:%" GST_TIME_FORMAT, 
+                 GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->splice_insert.pts_time)),
+                 GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->pts_adjustment)));
+             //We should have a PES header in the random_access TS packet. Error if not!
+             if (pesparsing_res == PES_PARSING_OK) {
+                 GST_DEBUG_OBJECT(parse, "PES header parsed with result PES_PARSING_OK; PID:0x%04x, PTS:%" GST_TIME_FORMAT, 
+                     packet->pid, GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+                if (tspad->program->program.spliceinfo->splice_insert.pts_time < pes.PTS) {
+                    //Looks like a splicing point, send downstream event....
+                    tspad->splicing_inprogress = TRUE;
+                    tspad->program->program.spliceinfo->splice_insert.pts_time = pes.PTS;
+                    tspad->program->program.streams[packet->pid]->already_spliced = TRUE;
+                    if (tspad->spliced_packets == NULL) {
+                        //Allocate a temp buffer for the packets that should go to the next buffer....
+                        //gst_debug_set_threshold_for_name("tsparse", GST_LEVEL_LOG);
+                        tspad->spliced_packets = gst_buffer_new();
+                        if (packet->afc_flags & 0x10) { //packet has PCR
+                            GST_BUFFER_PTS(tspad->spliced_packets) = current_timestamp;
+                            tspad->next_pcr=packet->pcr;
+                            GST_BUFFER_OFFSET(tspad->spliced_packets) = packet->offset;
+                            GST_BUFFER_DURATION(tspad->pending_packets) = GST_BUFFER_PTS(tspad->spliced_packets) - GST_BUFFER_PTS(tspad->pending_packets);
+                            if (set_packet_discontinuity_flag(parse,packet) == FALSE) {
+                                GST_WARNING_OBJECT(parse, "Setting discontinuity flag failed! Expect problems!");
+                            }
+                            GST_DEBUG_OBJECT(parse, "Started new spliced buffer with PCR:%" GST_TIME_FORMAT " Timestamp:%" GST_TIME_FORMAT " PTS:%"GST_TIME_FORMAT,
+                                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                                GST_TIME_ARGS(GST_BUFFER_PTS(tspad->spliced_packets)),
+                                GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+                        }
+                    }
+                }
+            }
+        }
+        else if (parse->parent.parse_private_sections==TRUE) {  //No splice event scheduled, let's check buffer duration and send force_key_unit event if duration is more than 15sec
+            GST_DEBUG_OBJECT(parse,"last_splice_ts:%"GST_TIME_FORMAT " , packet ts:%" GST_TIME_FORMAT, 
+                GST_TIME_ARGS(tspad->last_splice_ts),
+                GST_TIME_ARGS(current_timestamp));
+            if (tspad->last_splice_ts + 15*GST_SECOND < current_timestamp) {
+                GST_DEBUG_OBJECT(parse,"Ad-hoc splicing initiated at PCR:%" GST_TIME_FORMAT " Timestamp:%" GST_TIME_FORMAT, 
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                    GST_TIME_ARGS(current_timestamp));
+                ad_hoc_splice = TRUE;
+             /*   if (set_packet_discontinuity_flag(parse, packet) == FALSE) {
+                    GST_WARNING_OBJECT(parse, "Setting discontinuity flag failed! Expect problems!");
+                } */
+            }
+        }
+    }
+    if (tspad->splicing_inprogress == TRUE)
+        all_streams_spliced = mpegts_parse_tspad_all_streams_spliced(tspad, packet->pid);
+    else
+        all_streams_spliced = FALSE;
+   
+    if ((tspad->splicing_inprogress == FALSE && ((packet->afc_flags & 0x40) && (packet->afc_flags & 0x10) 
+        && (parse->parent.parse_private_sections==TRUE) &&  (tspad->pending_packets != NULL))) || //Random access flag and parse_private_section==TRUE
+        (tspad->splicing_inprogress && all_streams_spliced) || // Splicing done driven by X31 or SCTE35
+        (ad_hoc_splice==TRUE) ||  // Add hoc splice after 15sec
+        ((parse->parent.parse_private_sections==FALSE) && (packet->afc_flags & 0x10))) {// if parse_private_section==FALSE send out buffer at every PCR
+
+        //Here we just insert a packet with PCR as the last packet. 
+        if(tspad->splicing_inprogress && all_streams_spliced) {
+            GST_DEBUG_OBJECT(parse,"Inserting packet with PCR:%"GST_TIME_FORMAT " as the last packet.",
+                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(tspad->next_pcr)));
+            mpegts_parse_tspad_insert_adaptation_field_with_pcr(parse,tspad,parse->pcr_pid,PCRTIME_TO_GSTTIME(tspad->next_pcr),tspad->pending_packets);
+        }
+        //This is the generic part, we should push out the pending packets either if splicing or just found a random_access packet
+        //But set offset and duration first, if feeding payloader...
+        if(tspad->splicing_inprogress==FALSE &&  ad_hoc_splice==FALSE) {
+            if(GST_BUFFER_PTS(tspad->pending_packets)>current_timestamp) {
+                GST_WARNING_OBJECT(parse,"current timestamp:%"GST_TIME_FORMAT " is before buffer start:%"GST_TIME_FORMAT,
+                    GST_TIME_ARGS(current_timestamp),GST_TIME_ARGS(GST_BUFFER_PTS(tspad->pending_packets)));
+                GST_BUFFER_PTS(tspad->pending_packets)=current_timestamp;
+            }
+           
+            GST_BUFFER_DURATION(tspad->pending_packets) = current_timestamp - GST_BUFFER_PTS(tspad->pending_packets);
+            GST_BUFFER_OFFSET_END(tspad->pending_packets) = GST_BUFFER_OFFSET(tspad->pending_packets) + gst_buffer_get_size(tspad->pending_packets);
+        }
+
+        if(parse->parent.parse_private_sections==TRUE) {
+            GST_DEBUG_OBJECT(parse, "Pushing out pending packets...  Timestamp:%"GST_TIME_FORMAT " DUR:%"GST_TIME_FORMAT " SIZE:%ld FIRST_PCR:%"GST_TIME_FORMAT 
+                                " LAST_PCR:%" GST_TIME_FORMAT " PTS_MIN:%"GST_TIME_FORMAT " PTS_MAX:%"GST_TIME_FORMAT, 
+                GST_TIME_ARGS(GST_BUFFER_PTS(tspad->pending_packets)),
+                GST_TIME_ARGS(GST_BUFFER_DURATION(tspad->pending_packets)),
+                gst_buffer_get_size(tspad->pending_packets),
+                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(tspad->first_pcr)),
+                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(tspad->last_pcr)),
+                GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->min_pts)),
+                GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->max_pts)));
+        } else {
+            GST_DEBUG_OBJECT(parse, "Pushing out pending packets...  Timestamp:%"GST_TIME_FORMAT " DUR:%"GST_TIME_FORMAT " SIZE:%ld FIRST_PCR:%"GST_TIME_FORMAT, 
+                GST_TIME_ARGS(GST_BUFFER_PTS(tspad->pending_packets)),
+                GST_TIME_ARGS(GST_BUFFER_DURATION(tspad->pending_packets)),
+                gst_buffer_get_size(tspad->pending_packets),
+                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(tspad->first_pcr)));
+        }
+
+        ret = gst_pad_push(tspad->pad, tspad->pending_packets);
+        ret = gst_flow_combiner_update_flow(parse->flowcombiner, ret);
+        GST_DEBUG_OBJECT(parse,"Pending packets pushed with result:%i",ret);
+
+        tspad->pending_packets = NULL;
+
+        if ((tspad->splicing_inprogress && all_streams_spliced)||(ad_hoc_splice==TRUE)) {
+            //If splicing, send out the force_key_unit event.
+            GstEvent *spliceevent;
+            if (ad_hoc_splice == TRUE) {
+                tspad->last_splice_ts = current_timestamp;
+                splice_event_id = ++splice_event_index%2;
+            }
+            else {
+                tspad->last_splice_ts = GST_BUFFER_PTS(tspad->spliced_packets);
+                splice_event_id = tspad->program->program.spliceinfo->splice_insert.splice_event_id;
+            }
+            GST_DEBUG_OBJECT(parse, "Sending force_key_unit event. Splice timestamp:%" GST_TIME_FORMAT " PTS:%" GST_TIME_FORMAT " EventID:%i",
+                GST_TIME_ARGS(tspad->last_splice_ts),
+                GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)),
+                splice_event_id);
+            spliceevent = gst_video_event_new_downstream_force_key_unit(GST_CLOCK_TIME_NONE,/*tspad->last_splice_ts,*/ GST_CLOCK_TIME_NONE, GST_CLOCK_TIME_NONE, FALSE, splice_event_id);
+            gst_pad_push_event(tspad->pad, spliceevent); 
+            tspad->program->program.spliceinfo = NULL; //delete splice event as we've already served it.
+            if (GST_IS_BUFFER(tspad->spliced_packets)) {
+                if( tspad->has_pmt && tspad->has_pat ) {
+                    gst_buffer_insert_memory(tspad->spliced_packets, 0, tspad->pmt);
+                    gst_buffer_insert_memory(tspad->spliced_packets, 0, tspad->pat);
+                } else {
+                    GST_ERROR_OBJECT(parse,"No PMT or PAT in splicing buffer. Check incoming stream!");
+                }
+            }
+            tspad->pending_packets = tspad->spliced_packets;
+            tspad->has_pat = tspad->has_pmt = FALSE;
+            tspad->pat = tspad->pmt = NULL;
+            tspad->splicing_inprogress = FALSE;
+            tspad->spliced_packets = NULL;
+            g_list_foreach(tspad->program->program.stream_list, (GFunc)stream_clear_spliced_flag, NULL);
+            ad_hoc_splice = FALSE;
+            //Stop excesive debugging once spliced packets were pushed.
+            //gst_debug_set_threshold_for_name("tsparse", GST_LEVEL_DEBUG);
+        }
+    }
+            
+    if (tspad->pending_packets == NULL) {
+        //This is the first packet after start or pushing everything out except splicing
+        tspad->pending_packets = gst_buffer_new();
+        if(current_timestamp!=GST_CLOCK_TIME_NONE && packet->afc_flags&0x10) {
+            GST_BUFFER_PTS(tspad->pending_packets) = current_timestamp;
+            GST_BUFFER_OFFSET(tspad->pending_packets)=packet->offset;
+            tspad->first_pcr=tspad->last_pcr=packet->pcr;  
+        } else {
+            GST_ERROR_OBJECT(parse,"Created buffer but couldn't set timestamp, offset and PCR.");
+        }
+        if ((parse->parent.parse_private_sections==TRUE) && (packet->afc_flags & 0x10) && (packet->afc_flags & 0x40) 
+            && (packet->payload_unit_start_indicator)) { //packet has PCR and random-access flags and parse_private_section==TRUE
+            if (pesparsing_res == PES_PARSING_OK) {
+                tspad->min_pts=tspad->max_pts=pes.PTS;
+                GST_DEBUG_OBJECT(parse,"Start new buffer with  Timestamp:%" GST_TIME_FORMAT " PCR:%" GST_TIME_FORMAT " PTS:%" GST_TIME_FORMAT " Diff:%" GST_TIME_FORMAT, 
+                    GST_TIME_ARGS(current_timestamp),
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)),
+                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)-PCRTIME_TO_GSTTIME(packet->pcr)));
+            } else {
+                GST_ERROR_OBJECT(parse,"Couldn't parse PES header although random-access flag is present. afc:%02x",packet->afc_flags);
+                GST_ERROR_OBJECT(parse, "Program:%i PID:0x%04x afc:0x%02x, pusi:%i, size:%li", 
+                    tspad->program_number, packet->pid, packet->scram_afc_cc,
+                    packet->payload_unit_start_indicator,packet->data_end-packet->data_start);
+            }           
+        } else if ((parse->parent.parse_private_sections==FALSE) && packet->afc_flags &0x10) { 
+            GST_BUFFER_PTS(tspad->pending_packets) = current_timestamp;
+            GST_BUFFER_OFFSET(tspad->pending_packets)=packet->offset;
+            tspad->first_pcr=tspad->last_pcr=packet->pcr;  
+            GST_DEBUG_OBJECT(parse,"Start new buffer with  Timestamp:%" GST_TIME_FORMAT " PCR:%" GST_TIME_FORMAT, 
+                 GST_TIME_ARGS(current_timestamp),
+                 GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)));
+        }
+  
+    }
+    //Fix CC
+    if (!set_packet_cc(parse,tspad, packet)) {
+        GST_LOG_OBJECT(parse, "Could set CC for PID:0x%0x", packet->pid);
+    }
+    //Copy packet data to the allocated memory
+    GST_LOG_OBJECT(parse, "Adding memory to buffer.");
+    gst_memory_map(mem, &info, GST_MAP_WRITE);
+    memcpy(info.data, packet->data_start, packet->data_end - packet->data_start);
+    gst_memory_unmap(mem, &info);
+    //Decide if we have to add the memory to the pending_packet or to the splicing_packet buffer
+    if (tspad->splicing_inprogress) {
+        if (mpegts_parse_tspad_pid_spliced(tspad, packet->pid)) {
+            actual_buffer = tspad->spliced_packets;
+            GST_LOG_OBJECT(parse, "Using splicing buffer.");
+        }
+        else {
+            actual_buffer = tspad->pending_packets;
+            GST_LOG_OBJECT(parse,"Using pending buffer.");
+        }
+    }
+    else {
+        actual_buffer = tspad->pending_packets;
+    }
+    //FIXME: Store the min and max PTS for the current pending_packets buffer in tspad.
+    if((actual_buffer==tspad->pending_packets) && (parse->pcr_pid==packet->pid) && (packet->payload_unit_start_indicator==64)) {
+        //We have a video packet with PUSI set. Should have a PES packet with PTS.<==This is not True!!!!!
+        if (pesparsing_res == PES_PARSING_OK) {
+            if(pes.PTS<tspad->min_pts)
+                tspad->min_pts=pes.PTS;
+            if(pes.PTS>tspad->max_pts)
+                tspad->max_pts=pes.PTS;
+        }
+    }
+
+    //FIXME: Store last_pcr in tspad if packet has a PCR and it goes to pending_packets...
+    if((actual_buffer==tspad->pending_packets) && (packet->afc_flags & 0x10)) {
+        tspad->last_pcr=packet->pcr;
+    }
+
+    //FIXME: What is this???
+    if ((GST_BUFFER_PTS_IS_VALID(actual_buffer)) && !(packet->afc_flags & 0x80) && (packet->afc_flags & 0x10) && tspad->spliced_packets==NULL) {
+        //FIXME:We are here if actual_buffer is pending_packets and packet  has discontinuity and PCR flags set....
+        //      but if we have discontinuity we just pushed out pending_packets and this packet will be the first packet couple of lines later....
+        //      pending_packets was allocated by line 1036: if (tspad->pending_packets == NULL) ...
+        if(GST_BUFFER_PTS(actual_buffer)>current_timestamp) {
+            GST_WARNING_OBJECT(parse,"current timestamp:%"GST_TIME_FORMAT " is before buffer start:%"GST_TIME_FORMAT,
+                GST_TIME_ARGS(current_timestamp),GST_TIME_ARGS(GST_BUFFER_PTS(actual_buffer)));
+            GST_BUFFER_PTS(actual_buffer)=current_timestamp;
+        }
+        GST_BUFFER_DURATION(actual_buffer) = current_timestamp - GST_BUFFER_PTS(actual_buffer);
+        GST_BUFFER_OFFSET_END(actual_buffer) = packet->offset;
+    }
+    
+    if (section != NULL) {
+        if (section->table_id == 0x00 && tspad->has_pat==FALSE && tspad->splicing_inprogress) {
+//            gst_buffer_insert_memory(actual_buffer, 0, mem);
+            tspad->has_pat = TRUE;
+            tspad->pat = mem;
+            GST_DEBUG_OBJECT(parse, "PAT saved to tspad.");
+        } else if (section->table_id == 0x02 && tspad->has_pmt==FALSE && tspad->splicing_inprogress) {
+//            gst_buffer_insert_memory(actual_buffer, 1, mem);
+            tspad->has_pmt = TRUE;
+            tspad->pmt = mem;
+            GST_DEBUG_OBJECT(parse, "PMT saved to tspad");
+        }
+        else {
+            gst_buffer_append_memory(actual_buffer, mem);
+            GST_LOG_OBJECT(parse, "Packet with PID:0x%04x appended to buffer.", packet->pid);
+        }
+    } else {
+        gst_buffer_append_memory(actual_buffer, mem);
+        GST_LOG_OBJECT(parse, "Packet with PID:0x%04x appended to buffer.", packet->pid);
+    }
+    return ret;
+}
+
 static GstFlowReturn
 mpegts_parse_tspad_push_section (MpegTSParse2 * parse, MpegTSParsePad * tspad,
     GstMpegtsSection * section, MpegTSPacketizerPacket * packet)
@@ -549,17 +1278,12 @@ mpegts_parse_tspad_push_section (MpegTSParse2 * parse, MpegTSParsePad * tspad,
     }
   }
 
-  GST_DEBUG_OBJECT (parse,
+  GST_LOG_OBJECT (parse,
       "pushing section: %d program number: %d table_id: %d", to_push,
       tspad->program_number, section->table_id);
 
   if (to_push) {
-    GstBuffer *buf =
-        gst_buffer_new_and_alloc (packet->data_end - packet->data_start);
-    gst_buffer_fill (buf, 0, packet->data_start,
-        packet->data_end - packet->data_start);
-    ret = gst_pad_push (tspad->pad, buf);
-    ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+      ret = mpegts_parse_tspad_queue_packet(parse, tspad, packet,section);
   }
 
   GST_LOG_OBJECT (parse, "Returning %s", gst_flow_get_name (ret));
@@ -572,7 +1296,6 @@ mpegts_parse_tspad_push (MpegTSParse2 * parse, MpegTSParsePad * tspad,
 {
   GstFlowReturn ret = GST_FLOW_OK;
   MpegTSBaseProgram *bp = NULL;
-
   if (tspad->program_number != -1) {
     if (tspad->program)
       bp = (MpegTSBaseProgram *) tspad->program;
@@ -580,24 +1303,15 @@ mpegts_parse_tspad_push (MpegTSParse2 * parse, MpegTSParsePad * tspad,
       bp = mpegts_base_get_program ((MpegTSBase *) parse,
           tspad->program_number);
   }
-
   if (bp) {
     if (packet->pid == bp->pmt_pid || bp->streams == NULL
         || bp->streams[packet->pid]) {
-      GstBuffer *buf =
-          gst_buffer_new_and_alloc (packet->data_end - packet->data_start);
-      gst_buffer_fill (buf, 0, packet->data_start,
-          packet->data_end - packet->data_start);
-      /* push if there's no filter or if the pid is in the filter */
-      ret = gst_pad_push (tspad->pad, buf);
-      ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+        ret = mpegts_parse_tspad_queue_packet(parse, tspad, packet,NULL);
     }
   }
-  GST_DEBUG_OBJECT (parse, "Returning %s", gst_flow_get_name (ret));
-
   return ret;
 }
-
+ 
 static void
 pad_clear_for_push (GstPad * pad, MpegTSParse2 * parse)
 {
@@ -671,7 +1385,7 @@ mpegts_parse_push (MpegTSBase * base, MpegTSPacketizerPacket * packet,
         pads_cookie = GST_ELEMENT_CAST (parse)->pads_cookie;
         srcpads = parse->srcpads;
       } else {
-        GST_DEBUG ("getting next pad");
+        GST_LOG ("getting next pad");
         /* Get next pad */
         srcpads = g_list_next (srcpads);
       }
@@ -708,7 +1422,7 @@ mpegts_parse_inspect_packet (MpegTSBase * base, MpegTSPacketizerPacket * packet)
     if (parse->pcr_pid == packet->pid) {
       parse->current_pcr = mpegts_packetizer_pts_to_ts (base->packetizer,
           PCRTIME_TO_GSTTIME (packet->pcr), parse->pcr_pid);
-      GST_DEBUG ("Got new PCR %" GST_TIME_FORMAT " raw %" G_GUINT64_FORMAT,
+      GST_LOG ("Got new PCR %" GST_TIME_FORMAT " raw %" G_GUINT64_FORMAT,
           GST_TIME_ARGS (parse->current_pcr), packet->pcr);
       if (parse->base_pcr == GST_CLOCK_TIME_NONE) {
         parse->base_pcr = parse->current_pcr;
@@ -744,9 +1458,9 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstClockTime start_ts;
-  GstClockTime pcr = GST_CLOCK_TIME_NONE;
-  GstClockTime pcr_diff = 0;
-  gsize pcr_bytes, bytes_since_pcr, pos;
+  GstClockTime pcr = GST_CLOCK_TIME_NONE, dur;
+  GstClockTime pcr_diff = 0,out_ts;
+  gsize pcr_bytes, bytes_since_pcr, pos, buf_size;
   GstBuffer *buffer;
   GList *l, *end = NULL;
 
@@ -792,7 +1506,8 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
 
   /* Case 2 */
   if (!GST_CLOCK_TIME_IS_VALID (parse->previous_pcr)) {
-    pcr_diff = get_pending_timestamp_diff (parse);
+      GST_FIXME("There is no previous PCR, should happen only at the beginning.");
+     pcr_diff = get_pending_timestamp_diff (parse);
 
     /* Calculate the start_ts that ends at the end timestamp */
     start_ts = GST_CLOCK_TIME_NONE;
@@ -802,48 +1517,58 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
         start_ts -= pcr_diff;
     }
   } else if (drain_all) {       /* Case 3 */
-    start_ts = parse->previous_pcr;
-    pcr_diff = get_pending_timestamp_diff (parse);
+      GST_FIXME("drain_all is set. Should happen only at EOS.");
+      start_ts = parse->previous_pcr;
+      pcr_diff = get_pending_timestamp_diff (parse);
   } else {                      /* Case 4 */
     start_ts = parse->previous_pcr;
     if (GST_CLOCK_TIME_IS_VALID (pcr) && pcr > start_ts)
       pcr_diff = GST_CLOCK_DIFF (start_ts, pcr);
 
     /* Make sure PCR observations are sufficiently far apart */
-    if (drain_all == FALSE && pcr_diff < parse->smoothing_latency)
-      return GST_FLOW_OK;
+    if (drain_all == FALSE && pcr_diff < parse->smoothing_latency) {
+        GST_FIXME("pcr_diff is smaller than smoothing_latency. Not doing anything...");
+        return GST_FLOW_OK;
+    }
   }
 
-  GST_INFO_OBJECT (parse, "Pushing buffers - startTS %" GST_TIME_FORMAT
+  GST_LOG_OBJECT (parse, "Pushing buffers - startTS %" GST_TIME_FORMAT
       " duration %" GST_TIME_FORMAT " %" G_GSIZE_FORMAT " bytes",
       GST_TIME_ARGS (start_ts), GST_TIME_ARGS (pcr_diff), pcr_bytes);
 
   /* Now, push buffers out pacing timestamps over pcr_diff time and pcr_bytes */
   pos = 0;
   l = g_list_last (parse->pending_buffers);
+  out_ts = start_ts;
   while (l != end) {
     GList *p;
-    GstClockTime out_ts = start_ts;
-
     buffer = gst_buffer_make_writable (GST_BUFFER (l->data));
+    buf_size = gst_buffer_get_size(buffer);
 
     if (out_ts != GST_CLOCK_TIME_NONE && pcr_diff != GST_CLOCK_TIME_NONE &&
         pcr_bytes && pos)
-      out_ts += gst_util_uint64_scale (pcr_diff, pos, pcr_bytes);
+      out_ts = start_ts+gst_util_uint64_scale (pcr_diff, pos, pcr_bytes);
 
-    pos += gst_buffer_get_size (buffer);
+    if(pcr_bytes>0)
+        dur=gst_util_uint64_scale(pcr_diff,buf_size,pcr_bytes);
+    else {
+        dur=GST_CLOCK_TIME_NONE;
+        //dur = 0;
+    }
 
-    GST_DEBUG_OBJECT (parse,
-        "InputTS %" GST_TIME_FORMAT " out %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (GST_BUFFER_PTS (buffer)), GST_TIME_ARGS (out_ts));
+    GST_LOG_OBJECT (parse,
+        "InputTS %" GST_TIME_FORMAT " out %" GST_TIME_FORMAT " dur %" GST_TIME_FORMAT " bytes %" G_GSIZE_FORMAT, 
+        GST_TIME_ARGS (GST_BUFFER_PTS (buffer)), GST_TIME_ARGS (out_ts), GST_TIME_ARGS (dur),buf_size);
 
     GST_BUFFER_PTS (buffer) = out_ts + parse->ts_offset;
     GST_BUFFER_DTS (buffer) = out_ts + parse->ts_offset;
+    GST_BUFFER_DURATION (buffer) = dur;
     if (ret == GST_FLOW_OK) {
       ret = gst_pad_push (parse->srcpad, buffer);
       ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+      pos += buf_size;
     } else
-      gst_buffer_unref (buffer);
+        gst_buffer_unref (buffer);
 
     /* Free this list node and move to the next */
     p = g_list_previous (l);
@@ -866,7 +1591,7 @@ mpegts_parse_input_done (MpegTSBase * base, GstBuffer * buffer)
   GST_LOG_OBJECT (parse, "Received buffer %" GST_PTR_FORMAT, buffer);
 
   if (parse->current_pcr != GST_CLOCK_TIME_NONE) {
-    GST_DEBUG_OBJECT (parse,
+    GST_LOG_OBJECT (parse,
         "InputTS %" GST_TIME_FORMAT " PCR %" GST_TIME_FORMAT,
         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
         GST_TIME_ARGS (parse->current_pcr));
diff --git a/gst/mpegtsdemux/tsdemux.c b/gst/mpegtsdemux/tsdemux.c
index e5c78e7ad..0233b70e6 100644
--- a/gst/mpegtsdemux/tsdemux.c
+++ b/gst/mpegtsdemux/tsdemux.c
@@ -322,6 +322,7 @@ static void gst_ts_demux_stream_flush (TSDemuxStream * stream,
     GstTSDemux * demux, gboolean hard);
 
 static gboolean push_event (MpegTSBase * base, GstEvent * event);
+static gboolean sink_query (MpegTSBase * base, GstQuery * query);
 static void gst_ts_demux_check_and_sync_streams (GstTSDemux * demux,
     GstClockTime time);
 
@@ -394,6 +395,7 @@ gst_ts_demux_class_init (GstTSDemuxClass * klass)
   ts_class->reset = GST_DEBUG_FUNCPTR (gst_ts_demux_reset);
   ts_class->push = GST_DEBUG_FUNCPTR (gst_ts_demux_push);
   ts_class->push_event = GST_DEBUG_FUNCPTR (push_event);
+  ts_class->sink_query = GST_DEBUG_FUNCPTR (sink_query);
   ts_class->program_started = GST_DEBUG_FUNCPTR (gst_ts_demux_program_started);
   ts_class->program_stopped = GST_DEBUG_FUNCPTR (gst_ts_demux_program_stopped);
   ts_class->update_program = GST_DEBUG_FUNCPTR (gst_ts_demux_update_program);
@@ -1002,6 +1004,41 @@ push_event (MpegTSBase * base, GstEvent * event)
   return TRUE;
 }
 
+static gboolean
+sink_query (MpegTSBase * base, GstQuery * query)
+{
+  GstTSDemux *demux = (GstTSDemux *) base;
+  gboolean res = FALSE;
+/*
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_BITRATE:{
+      gint64 size_bytes;
+      GstClockTime duration;
+
+      if (gst_pad_peer_query_duration (base->sinkpad, GST_FORMAT_BYTES,
+              &size_bytes) && size_bytes > 0) {
+        if (gst_ts_demux_get_duration (demux, &duration) && duration > 0
+            && duration != GST_CLOCK_TIME_NONE) {
+          guint bitrate =
+              gst_util_uint64_scale (8 * size_bytes, GST_SECOND, duration);
+
+          GST_LOG_OBJECT (demux, "bitrate query byte length: %" G_GINT64_FORMAT
+              " duration %" GST_TIME_FORMAT " resulting in a bitrate of %u",
+              size_bytes, GST_TIME_ARGS (duration), bitrate);
+          gst_query_set_bitrate (query, bitrate);
+          res = TRUE;
+        }
+      }
+      break;
+    }
+    default:
+      res = GST_MPEGTS_BASE_CLASS (parent_class)->sink_query (base, query);
+      break;
+  }
+*/
+  return res;
+}
+
 static inline void
 add_iso639_language_to_tags (TSDemuxStream * stream, gchar * lang_code)
 {
diff --git a/gst/mpegtsmux/meson.build b/gst/mpegtsmux/meson.build
index 568b69575..5be65a209 100644
--- a/gst/mpegtsmux/meson.build
+++ b/gst/mpegtsmux/meson.build
@@ -17,3 +17,4 @@ gstmpegtsmux = library('gstmpegtsmux',
   install : true,
   install_dir : plugins_install_dir,
 )
+pkgconfig.generate(gstmpegtsmux, install_dir : plugins_pkgconfig_install_dir)
diff --git a/gst/mpegtsmux/mpegtsmux.c b/gst/mpegtsmux/mpegtsmux.c
index 99562fd45..b93c5aacb 100644
--- a/gst/mpegtsmux/mpegtsmux.c
+++ b/gst/mpegtsmux/mpegtsmux.c
@@ -115,17 +115,19 @@ enum
   PROP_PAT_INTERVAL,
   PROP_PMT_INTERVAL,
   PROP_ALIGNMENT,
-  PROP_SI_INTERVAL
+  PROP_SI_INTERVAL,
+  PROP_AUDIO_TYPE,
+  PROP_AUDIO_LANG
 };
 
 #define MPEGTSMUX_DEFAULT_ALIGNMENT    -1
 #define MPEGTSMUX_DEFAULT_M2TS         FALSE
 
 static GstStaticPadTemplate mpegtsmux_sink_factory =
-    GST_STATIC_PAD_TEMPLATE ("sink_%d",
+GST_STATIC_PAD_TEMPLATE("sink_%d",
     GST_PAD_SINK,
     GST_PAD_REQUEST,
-    GST_STATIC_CAPS ("video/mpeg, "
+    GST_STATIC_CAPS("video/mpeg, "
         "parsed = (boolean) TRUE, "
         "mpegversion = (int) { 1, 2, 4 }, "
         "systemstream = (boolean) false; "
@@ -156,6 +158,7 @@ static GstStaticPadTemplate mpegtsmux_sink_factory =
         "channels = (int) [1, 8], "
         "channel-mapping-family = (int) {0, 1};"
         "subpicture/x-dvb; application/x-teletext; meta/x-klv, parsed=true;"
+        "application/spliceinfo;"
         "image/x-jpc, profile = (int)[0, 49151];"));
 
 static GstStaticPadTemplate mpegtsmux_src_factory =
@@ -201,6 +204,7 @@ static gboolean mpegtsmux_send_event (GstElement * element, GstEvent * event);
 static void mpegtsmux_set_header_on_caps (MpegTsMux * mux);
 static gboolean mpegtsmux_src_event (GstPad * pad, GstObject * parent,
     GstEvent * event);
+static GstFlowReturn mpegtsmux_create_streams(MpegTsMux* mux, GstCollectData **best);
 
 #if 0
 static void mpegtsmux_set_index (GstElement * element, GstIndex * index);
@@ -305,6 +309,117 @@ mpegtsmux_class_init (MpegTsMuxClass * klass)
           "Set the interval (in ticks of the 90kHz clock) for writing out the Service"
           "Information tables", 1, G_MAXUINT, TSMUX_DEFAULT_SI_INTERVAL,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_AUDIO_TYPE,
+      g_param_spec_boxed ("audio-type", "Audio Type",
+          "A GstStructure specifies the type of audio elementary streams in programs",
+          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_AUDIO_LANG,
+      g_param_spec_boxed ("audio-lang", "Audio language",
+          "A GstStructure specifies the language code of the audio elementary streams in programs",
+          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+
+static gint 
+mpegtsmux_compare_timestamps(MpegTsMux *mux, GstCollectData *data1, GstCollectData *data2)
+{
+    GstClockTime ts1, ts2;
+    if (data1 == NULL || data2 == NULL) {
+        GST_ERROR("Cannot compare the timestamps of buffers. One of them is NULL!");
+            return 0;
+    }
+    if (GST_BUFFER_DTS(data1->buffer) != GST_CLOCK_TIME_NONE)
+        ts1 = GST_BUFFER_DTS(data1->buffer);
+    else
+        ts1 = GST_BUFFER_PTS(data1->buffer);
+
+    if (GST_BUFFER_DTS(data2->buffer) != GST_CLOCK_TIME_NONE)
+        ts2 = GST_BUFFER_DTS(data2->buffer);
+    else
+        ts2 = GST_BUFFER_PTS(data2->buffer);
+    GST_INFO_OBJECT(mux, "Comparing Pad:%s ts:%"GST_TIME_FORMAT " DTS:%" GST_TIME_FORMAT " with Pad:%s ts:%"GST_TIME_FORMAT " DTS:%"GST_TIME_FORMAT,
+        GST_PAD_NAME(data1->pad), GST_TIME_ARGS(ts1), GST_TIME_ARGS(GST_COLLECT_PADS_DTS(data1)), 
+        GST_PAD_NAME(data2->pad), GST_TIME_ARGS(ts2),GST_TIME_ARGS(GST_COLLECT_PADS_DTS(data2)));
+    if (ts1 < ts2)
+        return -1;
+    else if (ts2 < ts1)
+        return 1;
+    else
+        return 0;
+}
+static void
+mpegtsmux_collect_pads_find_best_pad(MpegTsMux *mux, GstCollectPads * pads,
+    GstCollectData ** data, GstClockTime * time)
+{
+    GSList *collected;
+    GstCollectData *best = NULL;
+    GstCollectData *video = NULL;
+    GstClockTime best_time = GST_CLOCK_TIME_NONE;
+
+    g_return_if_fail(data != NULL);
+    g_return_if_fail(time != NULL);
+
+    if (G_UNLIKELY(mux->first)) {
+        mpegtsmux_create_streams(mux,&best);
+        mpegtsmux_prepare_srcpad(mux);
+        mux->first = FALSE;
+    } 
+    if(best==NULL) {
+        for (collected = pads->data; collected; collected = g_slist_next(collected)) {
+            GstBuffer *buffer;
+            GstCollectData *data = (GstCollectData *)collected->data;
+            MpegTsPadData *ts_data = (MpegTsPadData *)collected->data;
+            GstClockTime timestamp;
+
+            buffer = gst_collect_pads_peek(pads, data);
+            /* if we have a buffer check if it is better then the current best one */
+            if (buffer != NULL) {
+                timestamp = GST_BUFFER_DTS(buffer);
+                if (!GST_CLOCK_TIME_IS_VALID(timestamp)) {
+                    timestamp = GST_BUFFER_PTS(buffer);
+                }
+                gst_buffer_unref(buffer);
+                if (best == NULL || best_time>timestamp) {
+                    best = data;
+                    best_time = timestamp;
+                }
+            }
+        }
+    }
+    *data = best;
+    *time = best_time;
+    GST_DEBUG_OBJECT(pads, "best pad %s, best time %" GST_TIME_FORMAT,
+        best ? GST_PAD_NAME(((GstCollectData *)best)->pad) : "(nil)",
+        GST_TIME_ARGS(best_time));
+}
+
+static GstFlowReturn
+mpegtsmux_collected(GstCollectPads *pads, gpointer user_data)
+{
+    GstFlowReturn ret = GST_FLOW_OK;
+    MpegTsMux *mux = (MpegTsMux*)user_data;
+    GSList *walk = mux->collect->data;
+    GstCollectData* data;
+    GstClockTime ts;
+    data = (GstCollectData *)walk->data;
+/*    while (walk) {
+        GstCollectData *c_data = (GstCollectData *)walk->data;
+        if (mpegtsmux_compare_timestamps( mux, data, c_data) < 0)
+            data = c_data;
+        walk = g_slist_next(walk);
+    } */
+    mpegtsmux_collect_pads_find_best_pad(mux, pads, &data, &ts);
+    if (data != NULL) {
+        GST_INFO_OBJECT(mux, "Oldest buffer is in Pad:%s with ts:%"GST_TIME_FORMAT,
+            GST_PAD_NAME(data->pad), GST_TIME_ARGS(ts));
+        return mpegtsmux_collected_buffer(pads, data, gst_collect_pads_pop(mux->collect, data), user_data);
+    }
+    else {
+        return mpegtsmux_collected_buffer(pads, NULL, NULL, user_data);
+    }
+
 }
 
 static void
@@ -318,16 +433,26 @@ mpegtsmux_init (MpegTsMux * mux)
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
   mux->collect = gst_collect_pads_new ();
+/*
   gst_collect_pads_set_buffer_function (mux->collect,
       (GstCollectPadsBufferFunction)
       GST_DEBUG_FUNCPTR (mpegtsmux_collected_buffer), mux);
+*/
+  gst_collect_pads_set_function(mux->collect,
+      (GstCollectPadsFunction)
+      GST_DEBUG_FUNCPTR(mpegtsmux_collected), mux);
+
 
   gst_collect_pads_set_event_function (mux->collect,
       (GstCollectPadsEventFunction) GST_DEBUG_FUNCPTR (mpegtsmux_sink_event),
       mux);
   gst_collect_pads_set_clip_function (mux->collect, (GstCollectPadsClipFunction)
       GST_DEBUG_FUNCPTR (mpegtsmux_clip_inc_running_time), mux);
+/*
+  gst_collect_pads_set_compare_function(mux->collect, (GstCollectPadsCompareFunction)
+      GST_DEBUG_FUNCPTR(mpegtsmux_compare_timestamps), mux);
 
+*/
   mux->adapter = gst_adapter_new ();
   mux->out_adapter = gst_adapter_new ();
 
@@ -511,7 +636,31 @@ gst_mpegtsmux_set_property (GObject * object, guint prop_id,
       mux->si_interval = g_value_get_uint (value);
       tsmux_set_si_interval (mux->tsmux, mux->si_interval);
       break;
-    default:
+    case PROP_AUDIO_TYPE:
+    {
+      const GstStructure *s = gst_value_get_structure(value);
+      if (mux->audio_type) {
+        gst_structure_free(mux->audio_type);
+      }
+      if (s)
+        mux->audio_type=gst_structure_copy(s);
+      else
+        mux->audio_type=NULL;
+      break;
+    }
+    case PROP_AUDIO_LANG:
+    {
+      const GstStructure *s = gst_value_get_structure(value);
+      if (mux->audio_lang) {
+        gst_structure_free(mux->audio_lang);
+      }
+      if (s)
+        mux->audio_lang=gst_structure_copy(s);
+      else
+        mux->audio_lang=NULL;
+      break;
+    }
+   default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
@@ -542,7 +691,13 @@ gst_mpegtsmux_get_property (GObject * object, guint prop_id,
     case PROP_SI_INTERVAL:
       g_value_set_uint (value, mux->si_interval);
       break;
-    default:
+    case PROP_AUDIO_TYPE:
+      gst_value_set_structure (value, mux->audio_type);
+      break;
+   case PROP_AUDIO_LANG:
+      gst_value_set_structure (value, mux->audio_lang);
+      break;
+   default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
@@ -633,6 +788,7 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
     st = TSMUX_ST_VIDEO_HEVC;
   } else if (strcmp (mt, "audio/mpeg") == 0) {
     gint mpegversion;
+    gint layer;
 
     if (!gst_structure_get_int (s, "mpegversion", &mpegversion)) {
       GST_ERROR_OBJECT (pad, "caps missing mpegversion");
@@ -664,6 +820,21 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
         GST_WARNING_OBJECT (pad, "unsupported mpegversion %d", mpegversion);
         goto not_negotiated;
     }
+    if (!gst_structure_get_int(s, "layer", &layer)) {
+        GST_ERROR_OBJECT(pad, "caps missing layer");
+        goto not_negotiated;
+    }
+    if(mux->audio_type && gst_structure_has_field(mux->audio_type,GST_PAD_NAME(pad))) {
+        gst_structure_get_int(mux->audio_type,GST_PAD_NAME(pad),&st);
+        GST_INFO_OBJECT(mux,"Stream type of %s is set to %i",GST_PAD_NAME(pad),st);
+    }
+/*
+    switch (layer) {
+    case 2:
+        st = TSMUX_ST_AUDIO_MPEG2;
+        break;
+    }
+*/
   } else if (strcmp (mt, "video/mpeg") == 0) {
     gint mpegversion;
 
@@ -692,7 +863,9 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
     st = TSMUX_ST_PS_TELETEXT;
     /* needs a particularly sized layout */
     ts_data->prepare_func = mpegtsmux_prepare_teletext;
-  } else if (strcmp (mt, "audio/x-opus") == 0) {
+  } else if(strcmp(mt, "application/spliceinfo") == 0) {
+      st = 134; //Streamtype:Spliceinfo FIXME: Set TSMUX_ST_SPLICEINFO to 134
+  } else if (strcmp(mt, "audio/x-opus") == 0) {
     guint8 channels, mapping_family, stream_count, coupled_count;
     guint8 channel_mapping[256];
 
@@ -843,6 +1016,13 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
     ts_data->prepare_data = private_data;
     ts_data->free_func = mpegtsmux_free_jpeg2000;
   }
+  if(mux->audio_lang && gst_structure_has_field(mux->audio_lang,GST_PAD_NAME(pad))) {
+        const char *lang=gst_structure_get_string(mux->audio_lang,GST_PAD_NAME(pad));   
+        if(ts_data->language)
+            g_free(ts_data->language);
+        ts_data->language=g_strdup(lang);
+        GST_INFO_OBJECT(mux,"Language of %s is set to %s",GST_PAD_NAME(pad),lang);
+  }
 
   if (st != TSMUX_ST_RESERVED) {
     ts_data->stream = tsmux_create_stream (mux->tsmux, st, ts_data->pid,
@@ -920,7 +1100,7 @@ not_negotiated:
 }
 
 static GstFlowReturn
-mpegtsmux_create_streams (MpegTsMux * mux)
+mpegtsmux_create_streams (MpegTsMux * mux, GstCollectData ** best)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GSList *walk = mux->collect->data;
@@ -930,6 +1110,7 @@ mpegtsmux_create_streams (MpegTsMux * mux)
     GstCollectData *c_data = (GstCollectData *) walk->data;
     MpegTsPadData *ts_data = (MpegTsPadData *) walk->data;
     gchar *name = NULL;
+    gchar *pcr_name, *pmt_name;
 
     walk = g_slist_next (walk);
 
@@ -972,6 +1153,7 @@ mpegtsmux_create_streams (MpegTsMux * mux)
           ts_data->pid, ts_data->prog_id);
 
       tsmux_program_set_pcr_stream (ts_data->prog, ts_data->stream);
+      *best = (GstCollectData*)ts_data;
     }
 
     if (ts_data->stream == NULL) {
@@ -979,6 +1161,33 @@ mpegtsmux_create_streams (MpegTsMux * mux)
       if (ret != GST_FLOW_OK)
         goto no_stream;
     }
+
+    /* Check for user-specified PCR PID */
+    pcr_name = g_strdup_printf ("PCR_%d", ts_data->prog->pgm_number);
+    if (mux->prog_map && gst_structure_has_field (mux->prog_map, pcr_name)) {
+      const gchar *sink_name =
+          gst_structure_get_string (mux->prog_map, pcr_name);
+
+      if (!g_strcmp0 (name, sink_name)) {
+        GST_DEBUG_OBJECT (mux, "User specified stream (pid=%d) as PCR for "
+            "program (prog_id = %d)", ts_data->pid, ts_data->prog->pgm_number);
+        tsmux_program_set_pcr_stream (ts_data->prog, ts_data->stream);
+      }
+    }
+    g_free (pcr_name);
+
+    /* Check for user-specified PMT PID */
+    pmt_name = g_strdup_printf("PMT_%d", ts_data->prog->pgm_number);
+    if (mux->prog_map && gst_structure_has_field(mux->prog_map, pmt_name)) {
+        guint pmt_pid;
+        gst_structure_get_int(mux->prog_map, pmt_name,&pmt_pid);        
+        GST_DEBUG_OBJECT(mux, "Structure:%s", gst_structure_to_string(mux->prog_map));
+        GST_DEBUG_OBJECT(mux, "User specified pid=%i as PMT pid for "
+           "program (prog_id = %d)", pmt_pid, ts_data->prog->pgm_number);
+        tsmux_program_set_pmt_pid(mux->tsmux, ts_data->prog, pmt_pid);
+    }
+    g_free(pmt_name);
+
   }
 
   return GST_FLOW_OK;
@@ -1086,6 +1295,25 @@ mpegtsmux_sink_event (GstCollectPads * pads, GstCollectData * data,
       }
       break;
     }
+    case GST_EVENT_FLUSH_STOP:{
+      GList *cur;
+
+      /* Send initial segments again after a flush-stop, and also resend the
+       * header sections */
+      mux->first = TRUE;
+
+      /* output PAT, SI tables */
+      tsmux_resend_pat (mux->tsmux);
+      tsmux_resend_si (mux->tsmux);
+
+      /* output PMT for each program */
+      for (cur = mux->tsmux->programs; cur; cur = cur->next) {
+        TsMuxProgram *program = (TsMuxProgram *) cur->data;
+
+        tsmux_resend_pmt (program);
+      }
+      break;
+    }
     default:
       break;
   }
@@ -1314,18 +1542,6 @@ mpegtsmux_collected_buffer (GstCollectPads * pads, GstCollectData * data,
 
   GST_DEBUG_OBJECT (mux, "Pads collected");
 
-  if (G_UNLIKELY (mux->first)) {
-    ret = mpegtsmux_create_streams (mux);
-    if (G_UNLIKELY (ret != GST_FLOW_OK)) {
-      if (buf)
-        gst_buffer_unref (buf);
-      return ret;
-    }
-
-    mpegtsmux_prepare_srcpad (mux);
-
-    mux->first = FALSE;
-  }
 
   if (G_UNLIKELY (best == NULL)) {
     /* EOS */
@@ -1338,7 +1554,7 @@ mpegtsmux_collected_buffer (GstCollectPads * pads, GstCollectData * data,
     if (buf)
       gst_buffer_unref (buf);
 
-    return GST_FLOW_OK;
+    return GST_FLOW_EOS;
   }
 
   prog = best->prog;
diff --git a/gst/mpegtsmux/mpegtsmux.h b/gst/mpegtsmux/mpegtsmux.h
index 169892c79..f42607ae7 100644
--- a/gst/mpegtsmux/mpegtsmux.h
+++ b/gst/mpegtsmux/mpegtsmux.h
@@ -139,6 +139,8 @@ struct MpegTsMux {
   guint pmt_interval;
   gint alignment;
   guint si_interval;
+  GstStructure *audio_type;
+  GstStructure *audio_lang;
 
   /* state */
   gboolean first;
diff --git a/gst/mpegtsmux/tsmux/tsmux.c b/gst/mpegtsmux/tsmux/tsmux.c
index 6fa9e0d12..8bb0b7fab 100644
--- a/gst/mpegtsmux/tsmux/tsmux.c
+++ b/gst/mpegtsmux/tsmux/tsmux.c
@@ -104,7 +104,7 @@
 /* HACK: We use a fixed buffering offset for the PCR at the moment - 
  * this is the amount 'in advance' of the stream that the PCR sits.
  * 1/8 second atm */
-#define TSMUX_PCR_OFFSET (TSMUX_CLOCK_FREQ / 8)
+#define TSMUX_PCR_OFFSET (TSMUX_CLOCK_FREQ )
 
 /* Times per second to write PCR */
 #define TSMUX_DEFAULT_PCR_FREQ (25)
@@ -512,6 +512,19 @@ tsmux_program_set_pcr_stream (TsMuxProgram * program, TsMuxStream * stream)
 
   program->pmt_changed = TRUE;
 }
+void
+tsmux_program_set_pmt_pid( TsMux *mux, TsMuxProgram * program, guint pmt_pid)
+{
+    g_return_if_fail(program != NULL);
+
+    if (program->pmt_pid == pmt_pid)
+        return;
+
+    program->pmt_pid = pmt_pid;
+
+    mux->pat_changed = TRUE;
+}
+
 
 /**
  * tsmux_get_new_pid:
diff --git a/gst/mpegtsmux/tsmux/tsmux.h b/gst/mpegtsmux/tsmux/tsmux.h
index 11a1480bb..924b23dc3 100644
--- a/gst/mpegtsmux/tsmux/tsmux.h
+++ b/gst/mpegtsmux/tsmux/tsmux.h
@@ -211,6 +211,7 @@ TsMuxStream *	tsmux_find_stream 		(TsMux *mux, guint16 pid);
 
 void 		tsmux_program_add_stream 	(TsMuxProgram *program, TsMuxStream *stream);
 void 		tsmux_program_set_pcr_stream 	(TsMuxProgram *program, TsMuxStream *stream);
+void 		tsmux_program_set_pmt_pid (TsMux *mux,TsMuxProgram *program, guint pmt_pid);
 
 /* writing stuff */
 gboolean 	tsmux_write_stream_packet 	(TsMux *mux, TsMuxStream *stream);
diff --git a/gst/mpegtsmux/tsmux/tsmuxstream.c b/gst/mpegtsmux/tsmux/tsmuxstream.c
index 4cbd21770..6385a7a23 100644
--- a/gst/mpegtsmux/tsmux/tsmuxstream.c
+++ b/gst/mpegtsmux/tsmux/tsmuxstream.c
@@ -229,6 +229,7 @@ tsmux_stream_new (guint16 pid, TsMuxStreamType stream_type)
 
   stream->pcr_ref = 0;
   stream->last_pcr = -1;
+  stream->first_packet = TRUE;
 
   return stream;
 }
@@ -304,7 +305,7 @@ tsmux_stream_consume (TsMuxStream * stream, guint len)
   stream->cur_buffer_consumed += len;
   stream->bytes_avail -= len;
 
-  if (stream->cur_buffer_consumed == 0)
+  if (stream->cur_buffer_consumed == 0 && stream->cur_buffer->size != 0)
     return;
 
   if (GST_CLOCK_STIME_IS_VALID (stream->cur_buffer->pts)) {
@@ -432,10 +433,12 @@ tsmux_stream_initialize_pes_packet (TsMuxStream * stream)
   stream->pi.flags &= ~(TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS |
       TSMUX_PACKET_FLAG_PES_WRITE_PTS);
 
-  if (GST_CLOCK_STIME_IS_VALID (stream->pts)
-      && GST_CLOCK_STIME_IS_VALID (stream->dts)
-      && stream->pts != stream->dts)
-    stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS;
+  if (GST_CLOCK_STIME_IS_VALID(stream->pts)
+      && GST_CLOCK_STIME_IS_VALID(stream->dts)
+      && stream->pts != stream->dts) {
+      stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS;
+      stream->pi.flags |= TSMUX_PACKET_FLAG_WRITE_PCR;
+  }
   else {
     if (GST_CLOCK_STIME_IS_VALID (stream->pts))
       stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS;
@@ -446,6 +449,12 @@ tsmux_stream_initialize_pes_packet (TsMuxStream * stream)
     if (buf->random_access) {
       stream->pi.flags |= TSMUX_PACKET_FLAG_RANDOM_ACCESS;
       stream->pi.flags |= TSMUX_PACKET_FLAG_ADAPTATION;
+      stream->pi.flags |= TSMUX_PACKET_FLAG_WRITE_PCR;
+    }
+    if (stream->first_packet) {
+        stream->pi.flags |= TSMUX_PACKET_FLAG_ADAPTATION;
+        stream->pi.flags |= TSMUX_PACKET_FLAG_DISCONT;
+        stream->first_packet = FALSE;
     }
   }
 
@@ -716,8 +725,10 @@ tsmux_stream_add_data (TsMuxStream * stream, guint8 * data, guint len,
   packet->pts = pts;
   packet->dts = dts;
 
-  if (stream->bytes_avail == 0)
-    stream->last_pts = pts;
+  if (stream->bytes_avail == 0) {
+      stream->last_dts = dts;
+      stream->last_pts = pts;
+  }
 
   stream->bytes_avail += len;
   stream->buffers = g_list_append (stream->buffers, packet);
@@ -974,7 +985,11 @@ tsmux_stream_get_es_descrs (TsMuxStream * stream,
 
       descriptor = gst_mpegts_descriptor_from_registration ("AC-3",
           add_info, 6);
+      g_ptr_array_add (pmt_stream->descriptors, descriptor);
 
+      descriptor =
+          gst_mpegts_descriptor_from_custom (GST_MTS_DESC_AC3_AUDIO_STREAM,
+          add_info, 6);
       g_ptr_array_add (pmt_stream->descriptors, descriptor);
 
       break;
@@ -1088,5 +1103,5 @@ tsmux_stream_get_pts (TsMuxStream * stream)
 {
   g_return_val_if_fail (stream != NULL, GST_CLOCK_STIME_NONE);
 
-  return stream->last_pts;
+  return stream->last_dts;
 }
diff --git a/gst/mpegtsmux/tsmux/tsmuxstream.h b/gst/mpegtsmux/tsmux/tsmuxstream.h
index 7edfb61ec..db41cd6cf 100644
--- a/gst/mpegtsmux/tsmux/tsmuxstream.h
+++ b/gst/mpegtsmux/tsmux/tsmuxstream.h
@@ -227,6 +227,7 @@ struct TsMuxStream {
   guint16 profile_and_level;
   gboolean interlace_mode;
   guint8 color_spec;
+  gboolean first_packet;
 };
 
 /* stream management */
diff --git a/sys/nvdec/Makefile.am b/sys/nvdec/Makefile.am
index 5539dd25c..ca40fc3d4 100644
--- a/sys/nvdec/Makefile.am
+++ b/sys/nvdec/Makefile.am
@@ -19,7 +19,8 @@ libgstnvdec_la_LIBADD = \
 	$(GST_GL_LIBS) \
 	$(GST_PBUTILS_LIBS) \
 	$(GST_VIDEO_LIBS) \
-	$(GST_LIBS) \
-	$(CUDA_LIBS) -lnvcuvid
+	$(GST_LIBS)
+
+libgstnvdec_la_LIBADD += $(CUDA_LIBS) -lnvcuvid
 
 libgstnvdec_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
diff --git a/sys/nvdec/gstnvdec.c b/sys/nvdec/gstnvdec.c
index 0ec83a8e9..2bc44d24e 100644
--- a/sys/nvdec/gstnvdec.c
+++ b/sys/nvdec/gstnvdec.c
@@ -31,9 +31,6 @@
 
 #include "gstnvdec.h"
 
-#include <gst/gl/gstglfuncs.h>
-#include <cudaGL.h>
-
 typedef enum
 {
   GST_NVDEC_QUEUE_ITEM_TYPE_SEQUENCE,
@@ -225,7 +222,7 @@ static GstStaticPadTemplate gst_nvdec_sink_template =
     GST_STATIC_CAPS ("video/x-h264, stream-format=byte-stream, alignment=au; "
         "video/x-h265, stream-format=byte-stream, alignment=au; "
         "video/mpeg, mpegversion={ 1, 2, 4 }, systemstream=false; "
-        "image/jpeg")
+        "image/jpeg; video/x-vp8; video/x-vp9")
     );
 
 static GstStaticPadTemplate gst_nvdec_src_template =
@@ -251,7 +248,7 @@ gst_nvdec_class_init (GstNvDecClass * klass)
       &gst_nvdec_src_template);
 
   gst_element_class_set_static_metadata (element_class, "NVDEC video decoder",
-      "Decoder/Video", "NVDEC video decoder",
+      "Codec/Decoder/Video/Hardware", "NVDEC video decoder",
       "Ericsson AB, http://www.ericsson.com");
 
   video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_nvdec_start);
@@ -537,6 +534,10 @@ gst_nvdec_set_format (GstVideoDecoder * decoder, GstVideoCodecState * state)
     parser_params.CodecType = cudaVideoCodec_JPEG;
   } else if (!g_strcmp0 (caps_name, "video/x-h265")) {
     parser_params.CodecType = cudaVideoCodec_HEVC;
+  } else if (!g_strcmp0 (caps_name, "video/x-vp8")) {
+    parser_params.CodecType = cudaVideoCodec_VP8;
+  } else if (!g_strcmp0 (caps_name, "video/x-vp9")) {
+    parser_params.CodecType = cudaVideoCodec_VP9;
   } else {
     GST_ERROR_OBJECT (nvdec, "failed to determine codec type");
     return FALSE;
@@ -693,10 +694,17 @@ handle_pending_frames (GstNvDec * nvdec)
           vinfo = &state->info;
           vinfo->fps_n = fps_n;
           vinfo->fps_d = fps_d;
-          if (format->progressive_sequence)
+          if (format->progressive_sequence) {
             vinfo->interlace_mode = GST_VIDEO_INTERLACE_MODE_PROGRESSIVE;
-          else
+
+            /* nvdec doesn't seem to deal with interlacing with hevc so rely
+             * on upstream's value */
+            if (format->codec == cudaVideoCodec_HEVC) {
+              vinfo->interlace_mode = nvdec->input_state->info.interlace_mode;
+            }
+          } else {
             vinfo->interlace_mode = GST_VIDEO_INTERLACE_MODE_MIXED;
+          }
 
           GST_LOG_OBJECT (decoder,
               "Reading colorimetry information full-range %d matrix %d transfer %d primaries %d",
diff --git a/sys/nvdec/gstnvdec.h b/sys/nvdec/gstnvdec.h
index 7bc6e8100..a643b1bf4 100644
--- a/sys/nvdec/gstnvdec.h
+++ b/sys/nvdec/gstnvdec.h
@@ -29,7 +29,9 @@
 #define __GST_NVDEC_H__
 
 #include <gst/gl/gl.h>
-#include <nvcuvid.h>
+#include <gst/gl/gstglfuncs.h>
+#include "nvcuvid.h"
+#include <cudaGL.h>
 
 G_BEGIN_DECLS
 
diff --git a/sys/nvenc/Makefile.am b/sys/nvenc/Makefile.am
index 8c2968eb8..376c9f41b 100644
--- a/sys/nvenc/Makefile.am
+++ b/sys/nvenc/Makefile.am
@@ -3,30 +3,34 @@ plugin_LTLIBRARIES = libgstnvenc.la
 libgstnvenc_la_SOURCES = \
 	gstnvenc.c \
 	gstnvbaseenc.c \
-	gstnvh264enc.c
+	gstnvh264enc.c \
+	gstnvh265enc.c
 
 noinst_HEADERS = \
 	gstnvenc.h \
 	gstnvbaseenc.h \
-	gstnvh264enc.h
+	gstnvh264enc.h \
+	gstnvh265enc.h
 
 libgstnvenc_la_CFLAGS = \
 	$(GST_PLUGINS_BAD_CFLAGS) \
 	$(GST_PBUTILS_CFLAGS) \
 	$(GST_VIDEO_CFLAGS) \
 	$(GST_CFLAGS) \
-	$(CUDA_CFLAGS) \
-	$(NVENCODE_CFLAGS)
+	$(CUDA_CFLAGS)
 
 libgstnvenc_la_LIBADD = \
 	$(GST_PBUTILS_LIBS) \
 	$(GST_VIDEO_LIBS) \
 	$(GST_LIBS) \
 	$(CUDA_LIBS) \
-	$(NVENCODE_LIBS)
+	$(GMODULE_NO_EXPORT_LIBS)
 
 if USE_NVENC_GST_GL
 libgstnvenc_la_CFLAGS += $(GST_GL_CFLAGS)
 libgstnvenc_la_LIBADD += $(GST_GL_LIBS)
 endif
 libgstnvenc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+
+EXTRA_DIST = \
+	nvEncodeAPI.h
diff --git a/sys/nvenc/gstnvbaseenc.c b/sys/nvenc/gstnvbaseenc.c
index e805a5bcb..42fe7ac92 100644
--- a/sys/nvenc/gstnvbaseenc.c
+++ b/sys/nvenc/gstnvbaseenc.c
@@ -27,10 +27,13 @@
 
 #include <string.h>
 
+#define GST_CAT_DEFAULT gst_nvenc_debug
+
 #if HAVE_NVENC_GST_GL
 #include <cuda.h>
 #include <cuda_runtime_api.h>
 #include <cuda_gl_interop.h>
+#include <cudaGL.h>
 #include <gst/gl/gl.h>
 #endif
 
@@ -139,23 +142,6 @@ _rc_mode_to_nv (GstNvRCMode mode)
   }
 }
 
-static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("video/x-raw, " "format = (string) { NV12, I420 }, "       // TODO: YV12, Y444 support
-        "width = (int) [ 16, 4096 ], height = (int) [ 16, 2160 ], "
-        "framerate = (fraction) [0, MAX],"
-        "interlace-mode = { progressive, mixed, interleaved } "
-#if HAVE_NVENC_GST_GL
-        ";"
-        "video/x-raw(memory:GLMemory), "
-        "format = (string) { NV12, Y444 }, "
-        "width = (int) [ 16, 4096 ], height = (int) [ 16, 2160 ], "
-        "framerate = (fraction) [0, MAX],"
-        "interlace-mode = { progressive, mixed, interleaved } "
-#endif
-    ));
-
 enum
 {
   PROP_0,
@@ -186,13 +172,17 @@ G_LOCK_DEFINE_STATIC (initialization_lock);
 struct gl_input_resource
 {
   GstGLMemory *gl_mem[GST_VIDEO_MAX_PLANES];
-  struct cudaGraphicsResource *cuda_texture;
-  gpointer cuda_plane_pointers[GST_VIDEO_MAX_PLANES];
+  CUgraphicsResource cuda_texture;
+  CUdeviceptr cuda_plane_pointers[GST_VIDEO_MAX_PLANES];
   gpointer cuda_pointer;
   gsize cuda_stride;
   gsize cuda_num_bytes;
   NV_ENC_REGISTER_RESOURCE nv_resource;
   NV_ENC_MAP_INPUT_RESOURCE nv_mapped_resource;
+
+  /* whether nv_mapped_resource was mapped via NvEncMapInputResource()
+   * and therefore should unmap via NvEncUnmapInputResource or not */
+  gboolean mapped;
 };
 #endif
 
@@ -224,7 +214,8 @@ static void gst_nv_base_enc_get_property (GObject * object, guint prop_id,
 static void gst_nv_base_enc_finalize (GObject * obj);
 static GstCaps *gst_nv_base_enc_getcaps (GstVideoEncoder * enc,
     GstCaps * filter);
-static gboolean gst_nv_base_enc_stop_bitstream_thread (GstNvBaseEnc * nvenc);
+static gboolean gst_nv_base_enc_stop_bitstream_thread (GstNvBaseEnc * nvenc,
+    gboolean force);
 
 static void
 gst_nv_base_enc_class_init (GstNvBaseEncClass * klass)
@@ -252,8 +243,6 @@ gst_nv_base_enc_class_init (GstNvBaseEncClass * klass)
   videoenc_class->finish = GST_DEBUG_FUNCPTR (gst_nv_base_enc_finish);
   videoenc_class->sink_query = GST_DEBUG_FUNCPTR (gst_nv_base_enc_sink_query);
 
-  gst_element_class_add_static_pad_template (element_class, &sink_factory);
-
   g_object_class_install_property (gobject_class, PROP_DEVICE_ID,
       g_param_spec_uint ("cuda-device-id",
           "Cuda Device ID",
@@ -307,9 +296,11 @@ _get_supported_input_formats (GstNvBaseEnc * nvenc)
   guint64 format_mask = 0;
   uint32_t i, num = 0;
   NV_ENC_BUFFER_FORMAT formats[64];
-  GValue list = G_VALUE_INIT;
   GValue val = G_VALUE_INIT;
 
+  if (nvenc->input_formats)
+    return TRUE;
+
   NvEncGetInputFormats (nvenc->encoder, nvenc_class->codec_id, formats,
       G_N_ELEMENTS (formats), &num);
 
@@ -376,30 +367,30 @@ _get_supported_input_formats (GstNvBaseEnc * nvenc)
   if (format_mask == 0)
     return FALSE;
 
+  GST_OBJECT_LOCK (nvenc);
+  nvenc->input_formats = g_new0 (GValue, 1);
+
   /* process a second time so we can add formats in the order we want */
-  g_value_init (&list, GST_TYPE_LIST);
+  g_value_init (nvenc->input_formats, GST_TYPE_LIST);
   g_value_init (&val, G_TYPE_STRING);
   if ((format_mask & (1 << GST_VIDEO_FORMAT_NV12))) {
     g_value_set_static_string (&val, "NV12");
-    gst_value_list_append_value (&list, &val);
+    gst_value_list_append_value (nvenc->input_formats, &val);
   }
   if ((format_mask & (1 << GST_VIDEO_FORMAT_YV12))) {
     g_value_set_static_string (&val, "YV12");
-    gst_value_list_append_value (&list, &val);
+    gst_value_list_append_value (nvenc->input_formats, &val);
   }
   if ((format_mask & (1 << GST_VIDEO_FORMAT_I420))) {
     g_value_set_static_string (&val, "I420");
-    gst_value_list_append_value (&list, &val);
+    gst_value_list_append_value (nvenc->input_formats, &val);
   }
   if ((format_mask & (1 << GST_VIDEO_FORMAT_Y444))) {
     g_value_set_static_string (&val, "Y444");
-    gst_value_list_append_value (&list, &val);
+    gst_value_list_append_value (nvenc->input_formats, &val);
   }
   g_value_unset (&val);
 
-  GST_OBJECT_LOCK (nvenc);
-  g_free (nvenc->input_formats);
-  nvenc->input_formats = g_memdup (&list, sizeof (GValue));
   GST_OBJECT_UNLOCK (nvenc);
 
   return TRUE;
@@ -448,9 +439,9 @@ gst_nv_base_enc_open (GstVideoEncoder * enc)
 static void
 gst_nv_base_enc_set_context (GstElement * element, GstContext * context)
 {
+#if HAVE_NVENC_GST_GL
   GstNvBaseEnc *nvenc = GST_NV_BASE_ENC (element);
 
-#if HAVE_NVENC_GST_GL
   gst_gl_handle_set_context (element, context,
       (GstGLDisplay **) & nvenc->display,
       (GstGLContext **) & nvenc->other_context);
@@ -465,7 +456,9 @@ gst_nv_base_enc_set_context (GstElement * element, GstContext * context)
 static gboolean
 gst_nv_base_enc_sink_query (GstVideoEncoder * enc, GstQuery * query)
 {
+#if HAVE_NVENC_GST_GL
   GstNvBaseEnc *nvenc = GST_NV_BASE_ENC (enc);
+#endif
 
   switch (GST_QUERY_TYPE (query)) {
 #if HAVE_NVENC_GST_GL
@@ -520,10 +513,15 @@ gst_nv_base_enc_stop (GstVideoEncoder * enc)
 {
   GstNvBaseEnc *nvenc = GST_NV_BASE_ENC (enc);
 
-  gst_nv_base_enc_stop_bitstream_thread (nvenc);
+  gst_nv_base_enc_stop_bitstream_thread (nvenc, TRUE);
 
   gst_nv_base_enc_free_buffers (nvenc);
 
+  if (nvenc->input_state) {
+    gst_video_codec_state_unref (nvenc->input_state);
+    nvenc->input_state = NULL;
+  }
+
   if (nvenc->bitstream_pool) {
     g_async_queue_unref (nvenc->bitstream_pool);
     nvenc->bitstream_pool = NULL;
@@ -573,7 +571,7 @@ _get_interlace_modes (GstNvBaseEnc * nvenc)
     g_value_set_static_string (&val, "interleaved");
     gst_value_list_append_value (list, &val);
     g_value_set_static_string (&val, "mixed");
-    gst_value_list_append_value (list, &val);
+    gst_value_list_append_and_take_value (list, &val);
   }
   /* TODO: figure out what nvenc frame based interlacing means in gst terms */
 
@@ -598,6 +596,7 @@ gst_nv_base_enc_getcaps (GstVideoEncoder * enc, GstCaps * filter)
 
     val = _get_interlace_modes (nvenc);
     gst_caps_set_value (supported_incaps, "interlace-mode", val);
+    g_value_unset (val);
     g_free (val);
 
     GST_LOG_OBJECT (enc, "codec input caps %" GST_PTR_FORMAT, supported_incaps);
@@ -639,6 +638,8 @@ gst_nv_base_enc_close (GstVideoEncoder * enc)
   }
 
   GST_OBJECT_LOCK (nvenc);
+  if (nvenc->input_formats)
+    g_value_unset (nvenc->input_formats);
   g_free (nvenc->input_formats);
   nvenc->input_formats = NULL;
   GST_OBJECT_UNLOCK (nvenc);
@@ -840,6 +841,8 @@ gst_nv_base_enc_bitstream_thread (gpointer user_data)
         nv_ret =
             NvEncUnmapInputResource (nvenc->encoder,
             in_gl_resource->nv_mapped_resource.mappedResource);
+        in_gl_resource->mapped = FALSE;
+
         if (nv_ret != NV_ENC_SUCCESS) {
           GST_ERROR_OBJECT (nvenc, "Failed to unmap input resource %p, ret %d",
               in_gl_resource, nv_ret);
@@ -892,29 +895,37 @@ gst_nv_base_enc_start_bitstream_thread (GstNvBaseEnc * nvenc)
 }
 
 static gboolean
-gst_nv_base_enc_stop_bitstream_thread (GstNvBaseEnc * nvenc)
+gst_nv_base_enc_stop_bitstream_thread (GstNvBaseEnc * nvenc, gboolean force)
 {
   gpointer out_buf;
 
   if (nvenc->bitstream_thread == NULL)
     return TRUE;
 
-  /* FIXME */
-  GST_FIXME_OBJECT (nvenc, "stop bitstream reading thread properly");
-  g_async_queue_lock (nvenc->bitstream_queue);
-  g_async_queue_lock (nvenc->bitstream_pool);
-  while ((out_buf = g_async_queue_try_pop_unlocked (nvenc->bitstream_queue))) {
-    GST_INFO_OBJECT (nvenc, "stole bitstream buffer %p from queue", out_buf);
-    g_async_queue_push_unlocked (nvenc->bitstream_pool, out_buf);
+  if (force) {
+    g_async_queue_lock (nvenc->bitstream_queue);
+    g_async_queue_lock (nvenc->bitstream_pool);
+    while ((out_buf = g_async_queue_try_pop_unlocked (nvenc->bitstream_queue))) {
+      GST_INFO_OBJECT (nvenc, "stole bitstream buffer %p from queue", out_buf);
+      g_async_queue_push_unlocked (nvenc->bitstream_pool, out_buf);
+    }
+    g_async_queue_push_unlocked (nvenc->bitstream_queue, SHUTDOWN_COOKIE);
+    g_async_queue_unlock (nvenc->bitstream_pool);
+    g_async_queue_unlock (nvenc->bitstream_queue);
+  } else {
+    /* wait for encoder to drain the remaining buffers */
+    g_async_queue_push (nvenc->bitstream_queue, SHUTDOWN_COOKIE);
+  }
+
+  if (!force) {
+    /* temporary unlock during finish, so other thread can find and push frame */
+    GST_VIDEO_ENCODER_STREAM_UNLOCK (nvenc);
   }
-  g_async_queue_push_unlocked (nvenc->bitstream_queue, SHUTDOWN_COOKIE);
-  g_async_queue_unlock (nvenc->bitstream_pool);
-  g_async_queue_unlock (nvenc->bitstream_queue);
 
-  /* temporary unlock, so other thread can find and push frame */
-  GST_VIDEO_ENCODER_STREAM_UNLOCK (nvenc);
   g_thread_join (nvenc->bitstream_thread);
-  GST_VIDEO_ENCODER_STREAM_LOCK (nvenc);
+
+  if (!force)
+    GST_VIDEO_ENCODER_STREAM_LOCK (nvenc);
 
   nvenc->bitstream_thread = NULL;
   return TRUE;
@@ -966,6 +977,20 @@ gst_nv_base_enc_free_buffers (GstNvBaseEnc * nvenc)
       struct gl_input_resource *in_gl_resource = nvenc->input_bufs[i];
 
       cuCtxPushCurrent (nvenc->cuda_ctx);
+
+      if (in_gl_resource->mapped) {
+        GST_LOG_OBJECT (nvenc, "Unmap resource %p", in_gl_resource);
+
+        nv_ret =
+            NvEncUnmapInputResource (nvenc->encoder,
+            in_gl_resource->nv_mapped_resource.mappedResource);
+
+        if (nv_ret != NV_ENC_SUCCESS) {
+          GST_ERROR_OBJECT (nvenc, "Failed to unmap input resource %p, ret %d",
+              in_gl_resource, nv_ret);
+        }
+      }
+
       nv_ret =
           NvEncUnregisterResource (nvenc->encoder,
           in_gl_resource->nv_resource.registeredResource);
@@ -973,6 +998,12 @@ gst_nv_base_enc_free_buffers (GstNvBaseEnc * nvenc)
         GST_ERROR_OBJECT (nvenc, "Failed to unregister resource %p, ret %d",
             in_gl_resource, nv_ret);
 
+      nv_ret = cuMemFree ((CUdeviceptr) in_gl_resource->cuda_pointer);
+      if (nv_ret != NV_ENC_SUCCESS) {
+        GST_ERROR_OBJECT (nvenc, "Failed to free CUDA device memory, ret %d",
+            nv_ret);
+      }
+
       g_free (in_gl_resource);
       cuCtxPopCurrent (NULL);
     } else
@@ -1468,6 +1499,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
   cudaError_t cuda_ret;
   guint8 *data_pointer;
   guint i;
+  CUDA_MEMCPY2D param;
 
   cuCtxPushCurrent (data->nvenc->cuda_ctx);
   data_pointer = data->in_gl_resource->cuda_pointer;
@@ -1495,7 +1527,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
         gl_mem->mem.tex_id);
 
     cuda_ret =
-        cudaGraphicsGLRegisterBuffer (&data->in_gl_resource->cuda_texture,
+        cuGraphicsGLRegisterBuffer (&data->in_gl_resource->cuda_texture,
         gl_buf_obj->id, cudaGraphicsRegisterFlagsReadOnly);
     if (cuda_ret != cudaSuccess) {
       GST_ERROR_OBJECT (data->nvenc, "failed to register GL texture %u to cuda "
@@ -1504,7 +1536,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
     }
 
     cuda_ret =
-        cudaGraphicsMapResources (1, &data->in_gl_resource->cuda_texture, 0);
+        cuGraphicsMapResources (1, &data->in_gl_resource->cuda_texture, 0);
     if (cuda_ret != cudaSuccess) {
       GST_ERROR_OBJECT (data->nvenc, "failed to map GL texture %u into cuda "
           "ret :%d", gl_mem->mem.tex_id, cuda_ret);
@@ -1512,7 +1544,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
     }
 
     cuda_ret =
-        cudaGraphicsResourceGetMappedPointer (&data->in_gl_resource->
+        cuGraphicsResourceGetMappedPointer (&data->in_gl_resource->
         cuda_plane_pointers[i], &data->in_gl_resource->cuda_num_bytes,
         data->in_gl_resource->cuda_texture);
     if (cuda_ret != cudaSuccess) {
@@ -1525,11 +1557,21 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
     dest_stride = data->in_gl_resource->cuda_stride;
 
     /* copy into scratch buffer */
-    cuda_ret =
-        cudaMemcpy2D (data_pointer, dest_stride,
-        data->in_gl_resource->cuda_plane_pointers[i], src_stride,
-        _get_plane_width (data->info, i) * plane_n_components,
-        _get_plane_height (data->info, i), cudaMemcpyDeviceToDevice);
+    param.srcXInBytes = 0;
+    param.srcY = 0;
+    param.srcMemoryType = CU_MEMORYTYPE_DEVICE;
+    param.srcDevice = data->in_gl_resource->cuda_plane_pointers[i];
+    param.srcPitch = src_stride;
+
+    param.dstXInBytes = 0;
+    param.dstY = 0;
+    param.dstMemoryType = CU_MEMORYTYPE_DEVICE;
+    param.dstDevice = (CUdeviceptr) data_pointer;
+    param.dstPitch = dest_stride;
+    param.WidthInBytes = _get_plane_width (data->info, i) * plane_n_components;
+    param.Height = _get_plane_height (data->info, i);
+
+    cuda_ret = cuMemcpy2D (&param);
     if (cuda_ret != cudaSuccess) {
       GST_ERROR_OBJECT (data->nvenc, "failed to copy GL texture %u into cuda "
           "ret :%d", gl_mem->mem.tex_id, cuda_ret);
@@ -1537,7 +1579,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
     }
 
     cuda_ret =
-        cudaGraphicsUnmapResources (1, &data->in_gl_resource->cuda_texture, 0);
+        cuGraphicsUnmapResources (1, &data->in_gl_resource->cuda_texture, 0);
     if (cuda_ret != cudaSuccess) {
       GST_ERROR_OBJECT (data->nvenc, "failed to unmap GL texture %u from cuda "
           "ret :%d", gl_mem->mem.tex_id, cuda_ret);
@@ -1545,7 +1587,7 @@ _map_gl_input_buffer (GstGLContext * context, struct map_gl_input *data)
     }
 
     cuda_ret =
-        cudaGraphicsUnregisterResource (data->in_gl_resource->cuda_texture);
+        cuGraphicsUnregisterResource (data->in_gl_resource->cuda_texture);
     if (cuda_ret != cudaSuccess) {
       GST_ERROR_OBJECT (data->nvenc, "failed to unregister GL texture %u from "
           "cuda ret :%d", gl_mem->mem.tex_id, cuda_ret);
@@ -1718,6 +1760,8 @@ gst_nv_base_enc_handle_frame (GstVideoEncoder * enc, GstVideoCodecFrame * frame)
       goto error;
     }
 
+    in_gl_resource->mapped = TRUE;
+
     out_buf = g_async_queue_try_pop (nvenc->bitstream_pool);
     if (out_buf == NULL) {
       GST_DEBUG_OBJECT (nvenc, "wait for output buf to become available again");
@@ -1900,12 +1944,10 @@ gst_nv_base_enc_finish (GstVideoEncoder * enc)
 {
   GstNvBaseEnc *nvenc = GST_NV_BASE_ENC (enc);
 
-  GST_FIXME_OBJECT (enc, "implement finish");
-
-  gst_nv_base_enc_drain_encoder (nvenc);
+  if (!gst_nv_base_enc_drain_encoder (nvenc))
+    return GST_FLOW_ERROR;
 
-  /* wait for encoder to output the remaining buffers */
-  gst_nv_base_enc_stop_bitstream_thread (nvenc);
+  gst_nv_base_enc_stop_bitstream_thread (nvenc, FALSE);
 
   return GST_FLOW_OK;
 }
diff --git a/sys/nvenc/gstnvenc.c b/sys/nvenc/gstnvenc.c
index 30b5b13f1..8fa83fc92 100644
--- a/sys/nvenc/gstnvenc.c
+++ b/sys/nvenc/gstnvenc.c
@@ -23,8 +23,25 @@
 
 #include "gstnvenc.h"
 #include "gstnvh264enc.h"
+#include "gstnvh265enc.h"
+#include <gmodule.h>
+
+#ifdef _WIN32
+#ifdef _WIN64
+#define NVENC_LIBRARY_NAME "nvEncodeAPI64.dll"
+#else
+#define NVENC_LIBRARY_NAME "nvEncodeAPI.dll"
+#endif
+#else
+#define NVENC_LIBRARY_NAME "libnvidia-encode.so.1"
+#endif
+
+typedef NVENCSTATUS NVENCAPI
+tNvEncodeAPICreateInstance (NV_ENCODE_API_FUNCTION_LIST * functionList);
+tNvEncodeAPICreateInstance *nvEncodeAPICreateInstance;
 
 GST_DEBUG_CATEGORY (gst_nvenc_debug);
+#define GST_CAT_DEFAULT gst_nvenc_debug
 
 static NV_ENCODE_API_FUNCTION_LIST nvenc_api;
 
@@ -285,9 +302,13 @@ gst_nvenc_create_cuda_context (guint device_id)
   for (i = 0; i < dev_count; ++i) {
     if (cuDeviceGet (&cdev, i) == CUDA_SUCCESS
         && cuDeviceGetName (name, sizeof (name), cdev) == CUDA_SUCCESS
-        && cuDeviceComputeCapability (&maj, &min, cdev) == CUDA_SUCCESS) {
-      GST_INFO ("GPU #%d supports NVENC: %s (%s) (Compute SM %d.%d)",
-          i, (((maj << 4) + min) >= 0x30) ? "yes" : "no", name, maj, min);
+        && cuDeviceGetAttribute (&maj,
+            CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, cdev) == CUDA_SUCCESS
+        && cuDeviceGetAttribute (&min,
+            CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR,
+            cdev) == CUDA_SUCCESS) {
+      GST_INFO ("GPU #%d supports NVENC: %s (%s) (Compute SM %d.%d)", i,
+          (((maj << 4) + min) >= 0x30) ? "yes" : "no", name, maj, min);
       if (i == device_id) {
         cuda_dev = cdev;
       }
@@ -321,19 +342,44 @@ gst_nvenc_destroy_cuda_context (CUcontext ctx)
   return (cuCtxDestroy (ctx) == CUDA_SUCCESS);
 }
 
+static gboolean
+load_nvenc_library (void)
+{
+  GModule *module;
+
+  module = g_module_open (NVENC_LIBRARY_NAME, G_MODULE_BIND_LAZY);
+  if (module == NULL) {
+    GST_ERROR ("%s", g_module_error ());
+    return FALSE;
+  }
+
+  if (!g_module_symbol (module, "NvEncodeAPICreateInstance",
+          (gpointer *) & nvEncodeAPICreateInstance)) {
+    GST_ERROR ("%s", g_module_error ());
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
   GST_DEBUG_CATEGORY_INIT (gst_nvenc_debug, "nvenc", 0, "Nvidia NVENC encoder");
 
   nvenc_api.version = NV_ENCODE_API_FUNCTION_LIST_VER;
-  if (NvEncodeAPICreateInstance (&nvenc_api) != NV_ENC_SUCCESS) {
+  if (!load_nvenc_library ())
+    return FALSE;
+
+  if (nvEncodeAPICreateInstance (&nvenc_api) != NV_ENC_SUCCESS) {
     GST_ERROR ("Failed to get NVEncodeAPI function table!");
   } else {
     GST_INFO ("Created NVEncodeAPI instance, got function table");
 
     gst_element_register (plugin, "nvh264enc", GST_RANK_PRIMARY * 2,
         gst_nv_h264_enc_get_type ());
+    gst_element_register (plugin, "nvh265enc", GST_RANK_PRIMARY * 2,
+        gst_nv_h265_enc_get_type ());
   }
 
   return TRUE;
diff --git a/sys/nvenc/gstnvenc.h b/sys/nvenc/gstnvenc.h
index f4eb34b6b..2af23ed1e 100644
--- a/sys/nvenc/gstnvenc.h
+++ b/sys/nvenc/gstnvenc.h
@@ -23,11 +23,10 @@
 #include <gst/gst.h>
 #include <gst/video/video.h>
 
-#include <nvEncodeAPI.h>
+#include "nvEncodeAPI.h"
 #include <cuda.h>
 
 GST_DEBUG_CATEGORY_EXTERN (gst_nvenc_debug);
-#define GST_CAT_DEFAULT gst_nvenc_debug
 
 CUcontext               gst_nvenc_create_cuda_context (guint device_id);
 
diff --git a/sys/nvenc/gstnvh264enc.c b/sys/nvenc/gstnvh264enc.c
index df25e7a59..5bae28095 100644
--- a/sys/nvenc/gstnvh264enc.c
+++ b/sys/nvenc/gstnvh264enc.c
@@ -27,23 +27,47 @@
 
 #include <string.h>
 
-#if HAVE_GST_GL
+GST_DEBUG_CATEGORY_STATIC (gst_nv_h264_enc_debug);
+#define GST_CAT_DEFAULT gst_nv_h264_enc_debug
+
+#if HAVE_NVENC_GST_GL
 #include <cuda.h>
 #include <cuda_runtime_api.h>
 #include <cuda_gl_interop.h>
-#define GST_USE_UNSTABLE_API
 #include <gst/gl/gl.h>
 #endif
 
 #define parent_class gst_nv_h264_enc_parent_class
 G_DEFINE_TYPE (GstNvH264Enc, gst_nv_h264_enc, GST_TYPE_NV_BASE_ENC);
 
+#if HAVE_NVENC_GST_GL
+#define GL_CAPS_STR \
+  ";" \
+  "video/x-raw(memory:GLMemory), " \
+  "format = (string) { NV12, Y444 }, " \
+  "width = (int) [ 16, 4096 ], height = (int) [ 16, 4096 ], " \
+  "framerate = (fraction) [0, MAX]," \
+  "interlace-mode = { progressive, mixed, interleaved } "
+#else
+#define GL_CAPS_STR ""
+#endif
+
 /* *INDENT-OFF* */
+static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-raw, " "format = (string) { NV12, I420 }, "       // TODO: YV12, Y444 support
+        "width = (int) [ 16, 4096 ], height = (int) [ 16, 4096 ], "
+        "framerate = (fraction) [0, MAX],"
+        "interlace-mode = { progressive, mixed, interleaved } "
+        GL_CAPS_STR
+    ));
+
 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("video/x-h264, "
-        "width = (int) [ 1, 4096 ], height = (int) [ 1, 2160 ], "
+        "width = (int) [ 1, 4096 ], height = (int) [ 1, 4096 ], "
         "framerate = (fraction) [0/1, MAX], "
         "stream-format = (string) byte-stream, " // TODO: avc support
         "alignment = (string) au, "
@@ -89,14 +113,18 @@ gst_nv_h264_enc_class_init (GstNvH264EncClass * klass)
   nvenc_class->set_src_caps = gst_nv_h264_enc_set_src_caps;
   nvenc_class->set_pic_params = gst_nv_h264_enc_set_pic_params;
 
+  gst_element_class_add_static_pad_template (element_class, &sink_factory);
   gst_element_class_add_static_pad_template (element_class, &src_factory);
 
   gst_element_class_set_static_metadata (element_class,
       "NVENC H.264 Video Encoder",
-      "Codec/Encoder/Video",
+      "Codec/Encoder/Video/Hardware",
       "Encode H.264 video streams using NVIDIA's hardware-accelerated NVENC encoder API",
       "Tim-Philipp Müller <tim@centricular.com>\n"
       "Matthew Waters <matthew@centricular.com>");
+
+  GST_DEBUG_CATEGORY_INIT (gst_nv_h264_enc_debug,
+      "nvh264enc", 0, "Nvidia H.264 encoder");
 }
 
 static void
@@ -119,6 +147,9 @@ _get_supported_profiles (GstNvH264Enc * nvenc)
   GValue val = G_VALUE_INIT;
   guint i, n, n_profiles;
 
+  if (nvenc->supported_profiles)
+    return TRUE;
+
   nv_ret =
       NvEncGetEncodeProfileGUIDCount (GST_NV_BASE_ENC (nvenc)->encoder,
       NV_ENC_CODEC_H264_GUID, &n);
@@ -161,8 +192,8 @@ _get_supported_profiles (GstNvH264Enc * nvenc)
     return FALSE;
 
   GST_OBJECT_LOCK (nvenc);
-  g_free (nvenc->supported_profiles);
-  nvenc->supported_profiles = g_memdup (&list, sizeof (GValue));
+  nvenc->supported_profiles = g_new0 (GValue, 1);
+  *nvenc->supported_profiles = list;
   GST_OBJECT_UNLOCK (nvenc);
 
   return TRUE;
@@ -211,6 +242,8 @@ gst_nv_h264_enc_close (GstVideoEncoder * enc)
   GstNvH264Enc *nvenc = GST_NV_H264_ENC (enc);
 
   GST_OBJECT_LOCK (nvenc);
+  if (nvenc->supported_profiles)
+    g_value_unset (nvenc->supported_profiles);
   g_free (nvenc->supported_profiles);
   nvenc->supported_profiles = NULL;
   GST_OBJECT_UNLOCK (nvenc);
@@ -244,6 +277,7 @@ _get_interlace_modes (GstNvH264Enc * nvenc)
     gst_value_list_append_value (list, &val);
     g_value_set_static_string (&val, "mixed");
     gst_value_list_append_value (list, &val);
+    g_value_unset (&val);
   }
   /* TODO: figure out what nvenc frame based interlacing means in gst terms */
 
@@ -269,6 +303,7 @@ gst_nv_h264_enc_getcaps (GstVideoEncoder * enc, GstCaps * filter)
 
     val = _get_interlace_modes (nvenc);
     gst_caps_set_value (supported_incaps, "interlace-mode", val);
+    g_value_unset (val);
     g_free (val);
 
     GST_LOG_OBJECT (enc, "codec input caps %" GST_PTR_FORMAT, supported_incaps);
diff --git a/gst-libs/gst/mpegts/gst-scte-section.c b/gst-libs/gst/mpegts/gst-scte-section.c
new file mode 100644
index 000000000..fcdafbc48
--- /dev/null
+++ b/gst-libs/gst/mpegts/gst-scte-section.c
@@ -0,0 +1,158 @@
+/*
+  * Copyright (C) 2019 Lajos Okos
+  *
+  * Authors:
+  *   Lajos Okos <lajos.okos@gmail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+*/
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+ 
+#include "mpegts.h"
+#include "gstmpegts-private.h"
+
+static void
+_gst_mpegts_scte_splice_command_free (GstMpegtsScteSpliceInsert *spinsert)
+{
+   //g_ptr_array_unref (spinfo->???);
+   //g_ptr_array_unref (spinfo->descriptors);
+   g_slice_free (GstMpegtsScteSpliceInsert, spinsert);
+}
+
+static gpointer
+_parse_scte_splice_info (GstMpegtsSection * section)
+{
+   GstMpegtsScteSpliceInfo *spinfo = NULL;
+   guint8 *data, *end;
+    
+   spinfo = g_slice_new0 (GstMpegtsScteSpliceInfo);
+ 
+   data = section->data;
+   end = data + section->section_length;
+   spinfo->table_id=*data++;
+   spinfo->section_syntax_indicator=*data>>7;
+   spinfo->private_indicator=(*data>>6)&0x01;
+   spinfo->section_length=(*data&0x0f*256) + *(data+1);
+   data+=2;
+   spinfo->protocol_version=*data++;
+   spinfo->encrypted_packet=*data>>7;
+   spinfo->encryption_algorith=(*data>>1)&0x3f;
+   spinfo->pts_adjustment=(guint64)(*data&0x01)<<32|*(data+1)<<24|*(data+2)<<16|*(data+3)<<8|*(data+4);
+   data+=5;
+   spinfo->cw_index=*data++;
+   spinfo->tier=*data<<4|(*(data+1)&0xf0)>>4;
+   spinfo->splice_command_length=(*(data+1)&0x0f)<<4|*(data+2);
+   data+=3;
+   spinfo->splice_command_type=*data++;
+   switch (spinfo->splice_command_type) {
+      case 0x05: {  //Splice Insert
+        GstMpegtsScteSpliceInsert *spinsert = &spinfo->splice_insert;
+        spinsert->splice_event_id=*data<<24|*(data+1)<<16|*(data+2)<<8|*(data+3);
+        data+=4;
+        spinsert->splice_event_cancel_indicator=*data++>>7;
+        spinsert->out_of_network_indicator=*data>>7;
+        spinsert->program_splice_flag=(*data>>6)&0x01;
+        spinsert->duration_flag=(*data>>5)&0x01;
+        spinsert->splice_immediate_flag=(*data++>>4)&0x01;
+        spinsert->time_specified_flag=*data>>7;
+        spinsert->pts_time=(((guint64)((*data)&0x01)<<32)|(*(data+1)<<24)|(*(data+2)<<16)|(*(data+3)<<8)|*(data+4)) & 0x1ffffffff;
+        data+=5;
+        spinsert->unique_program_id=*data<<8|*(data+1);
+        data+=2;
+        spinsert->avail_num=*data++;
+        spinsert->avails_expected=*data++;
+     }
+      break;
+      case 0x00:   //Splice Null
+      default: {}    //Unkown command
+        //spinfo->splice_command=NULL;
+   }
+
+   return (gpointer) spinfo;
+}
+
+static void
+_gst_mpegts_scte_splice_info_free (GstMpegtsScteSpliceInfo * spinfo)
+ {
+   //g_ptr_array_unref (spinfo->???);
+   //g_ptr_array_unref (spinfo->descriptors);
+   g_slice_free (GstMpegtsScteSpliceInfo, spinfo);
+}
+
+const GstMpegtsScteSpliceInfo *
+gst_mpegts_section_get_scte_splice_info (GstMpegtsSection * section)
+ {
+   g_return_val_if_fail (section->section_type == GST_MPEGTS_SECTION_SCTE_SPLICING,
+       NULL);
+   g_return_val_if_fail (section->cached_parsed || section->data, NULL);
+ 
+   if (!section->cached_parsed)
+     section->cached_parsed =
+         __common_section_checks (section, 3, _parse_scte_splice_info,
+         (GDestroyNotify) _gst_mpegts_scte_splice_info_free);
+ 
+   return (const GstMpegtsScteSpliceInfo *) section->cached_parsed;
+}
+
+/* 
+GstStructure should have the below fields:
+    splice-event-id (uint) : Must be present. Repeting IDs are ignored by downstream elements!!!
+    out-of-network-indicator (boolean) : 1 means exit from the network feed, 0 means return
+    pts-time (uint64) : PTS when splicing should happen
+    program-number (uint) : program number the event belons to. Used in mpegtsbase.c
+*/
+
+const GstMpegtsScteSpliceInfo*
+gst_mpegts_set_scte_splice_info(GstStructure *s)
+{
+    GstMpegtsScteSpliceInfo *spinfo = NULL;
+    GstMpegtsScteSpliceInsert *spinsert = NULL;
+
+    spinfo = g_slice_new0(GstMpegtsScteSpliceInfo);
+    spinsert = &spinfo->splice_insert;
+
+    spinfo->table_id = 0xfc; // Defined by the standard
+    spinfo->section_syntax_indicator = 0; // Defined by the standard
+    spinfo->private_indicator = 0; // Defined by the standard
+    spinfo->section_length = 0; // FIXME: Should be better calculated!!!
+    spinfo->protocol_version = 0; // Defined by the standard
+    spinfo->encrypted_packet = 0; // Defined by the standard
+    spinfo->encryption_algorith = 0; // Defined by the standard
+    spinfo->pts_adjustment = 0;
+    spinfo->cw_index = 0;
+    spinfo->tier = 0xfff;
+    spinfo->splice_command_length = 0; // FIXME: Should be better calculated!!!
+    spinfo->splice_command_type = 0x05;
+    gst_structure_get_uint(s, "splice-event-id", &spinsert->splice_event_id);
+    spinsert->splice_event_cancel_indicator = 0; // Not implemented yet. FIXME: Should be implemented sooner or later.
+    gst_structure_get_boolean(s,"out-of-network-indicator",&spinsert->out_of_network_indicator);
+    spinsert->program_splice_flag = 1;  // Program splice mode
+    spinsert->duration_flag = 0;  // No break duration ios indicated in the event
+    spinsert->splice_immediate_flag = 0;  // Splice time is present
+    spinsert->time_specified_flag = 1;  // PTS present
+    gst_structure_get_uint64(s,"pts-time",&spinsert->pts_time);
+    spinsert->unique_program_id = 0;
+    spinsert->avail_num = 0;
+    spinsert->avails_expected = 0;
+    return (const GstMpegtsScteSpliceInfo*)spinfo;
+}
