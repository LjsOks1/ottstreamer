diff --git a/gst-libs/gst/mpegts/Makefile.am b/gst-libs/gst/mpegts/Makefile.am
index 59a3ddd..38b1ab2 100644
--- a/gst-libs/gst/mpegts/Makefile.am
+++ b/gst-libs/gst/mpegts/Makefile.am
@@ -5,7 +5,8 @@ libgstmpegts_@GST_API_VERSION@_la_SOURCES = \
 	gstmpegtsdescriptor.c \
 	gst-dvb-descriptor.c \
 	gst-dvb-section.c \
-	gst-atsc-section.c
+	gst-atsc-section.c \
+        gst-scte-section.c
 
 libgstmpegts_@GST_API_VERSION@includedir = \
 	$(includedir)/gstreamer-@GST_API_VERSION@/gst/mpegts
diff --git a/gst-libs/gst/mpegts/gst-scte-section.h b/gst-libs/gst/mpegts/gst-scte-section.h
index 34c43cd..794a4cb 100644
--- a/gst-libs/gst/mpegts/gst-scte-section.h
+++ b/gst-libs/gst/mpegts/gst-scte-section.h
@@ -52,6 +52,7 @@ typedef enum {
   GST_MPEGTS_STREAM_TYPE_SCTE_SUBTITLING = 0x82,   /* Subtitling data */
   GST_MPEGTS_STREAM_TYPE_SCTE_ISOCH_DATA = 0x83,   /* Isochronous data */
   /* 0x84 - 0x94 : defined in other specs */
+  GST_MPEGTS_STREAM_TYPE_SCTE_SPLICING   = 0x86,   /* Lajos: SCTE35 stream type */
   GST_MPEGTS_STREAM_TYPE_SCTE_DST_NRT    = 0x95,   /* DST / NRT data */
   /* 0x96 - 0xaf : defined in other specs */
   GST_MPEGTS_STREAM_TYPE_SCTE_DSMCC_DCB  = 0xb0,   /* Data Carousel Type B */
@@ -97,6 +98,52 @@ typedef enum {
 
 } GstMpegtsSectionSCTETableID;
 
+typedef struct _GstMpegtsScteSpliceInsert GstMpegtsScteSpliceInsert;
+
+struct _GstMpegtsScteSpliceInsert
+{
+  guint32 splice_event_id;
+  gboolean splice_event_cancel_indicator;
+  gboolean out_of_network_indicator;
+  gboolean program_splice_flag;
+  gboolean duration_flag;
+  gboolean splice_immediate_flag;
+  gboolean time_specified_flag;
+  guint64 pts_time;
+  guint16 unique_program_id;
+  guint8 avail_num;
+  guint8 avails_expected;
+} ;
+
+typedef struct _GstMpegtsScteSpliceInfo GstMpegtsScteSpliceInfo;
+
+struct _GstMpegtsScteSpliceInfo
+{
+  guint8 table_id;
+  gboolean section_syntax_indicator;
+  gboolean private_indicator;
+  guint16 section_length;
+  guint8 protocol_version;
+  gboolean encrypted_packet;
+  guint8 encryption_algorith;
+  guint64 pts_adjustment;
+  guint8 cw_index;
+  guint16 tier;
+  guint16 splice_command_length;
+  guint8 splice_command_type;
+  GstMpegtsScteSpliceInsert splice_insert;
+  GPtrArray *descriptors;
+} ;
+
+
+GST_MPEGTS_API
+const GstMpegtsScteSpliceInfo *
+gst_mpegts_section_get_scte_splice_info (GstMpegtsSection *section);
+
+GST_MPEGTS_API
+const GstMpegtsScteSpliceInfo*
+gst_mpegts_set_scte_splice_info(GstStructure *s);
+
 G_END_DECLS
 
 #endif  /* GST_SCTE_SECTION_H */
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.c b/gst-libs/gst/mpegts/gstmpegtssection.c
index 41c970a..5b1674c 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.c
+++ b/gst-libs/gst/mpegts/gstmpegtssection.c
@@ -79,6 +79,7 @@ static GQuark QUARK_EIT;
 static GQuark QUARK_TDT;
 static GQuark QUARK_TOT;
 static GQuark QUARK_SECTION;
+static GQuark QUARK_SIT;
 
 static GType _gst_mpegts_section_type = 0;
 #define MPEG_TYPE_TS_SECTION (_gst_mpegts_section_type)
@@ -297,6 +298,9 @@ _mpegts_section_get_structure (GstMpegtsSection * section)
     case GST_MPEGTS_SECTION_TOT:
       quark = QUARK_TOT;
       break;
+    case GST_MPEGTS_SECTION_SCTE_SPLICING:
+      quark = QUARK_SIT;
+      break;
     default:
       GST_DEBUG ("Creating structure for unknown GstMpegtsSection");
       quark = QUARK_SECTION;
@@ -1013,7 +1017,7 @@ gst_mpegts_initialize (void)
   QUARK_TDT = g_quark_from_string ("tdt");
   QUARK_TOT = g_quark_from_string ("tot");
   QUARK_SECTION = g_quark_from_string ("section");
-
+  QUARK_SIT = g_quark_from_string ("sit");
   __initialize_descriptors ();
 }
 
@@ -1078,6 +1082,9 @@ _identify_section (guint16 pid, guint8 table_id)
       if (pid == 0x1ffb)
         return GST_MPEGTS_SECTION_ATSC_STT;
       break;
+    case GST_MTS_TABLE_ID_SCTE_SPLICE:  
+        return GST_MPEGTS_SECTION_SCTE_SPLICING;
+      break;
     default:
       /* Handle ranges */
       if (table_id >= GST_MTS_TABLE_ID_EVENT_INFORMATION_ACTUAL_TS_PRESENT &&
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.h b/gst-libs/gst/mpegts/gstmpegtssection.h
index 6054edf..4ed306e 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.h
+++ b/gst-libs/gst/mpegts/gstmpegtssection.h
@@ -78,7 +78,8 @@ typedef enum {
   GST_MPEGTS_SECTION_ATSC_MGT,
   GST_MPEGTS_SECTION_ATSC_ETT,
   GST_MPEGTS_SECTION_ATSC_EIT,
-  GST_MPEGTS_SECTION_ATSC_STT
+  GST_MPEGTS_SECTION_ATSC_STT,
+  GST_MPEGTS_SECTION_SCTE_SPLICING
 } GstMpegtsSectionType;
 
 /**
diff --git a/gst-libs/gst/mpegts/meson.build b/gst-libs/gst/mpegts/meson.build
index fc6a263..7fdb14c 100644
--- a/gst-libs/gst/mpegts/meson.build
+++ b/gst-libs/gst/mpegts/meson.build
@@ -4,6 +4,7 @@ mpegts_sources = [
   'gst-dvb-descriptor.c',
   'gst-dvb-section.c',
   'gst-atsc-section.c',
+  'gst-scte-section.c',
 ]
 
 mpegts_headers = [
diff --git a/gst/mpegtsdemux/mpegtsbase.c b/gst/mpegtsdemux/mpegtsbase.c
index 1a68f86..a0e5466 100644
--- a/gst/mpegtsdemux/mpegtsbase.c
+++ b/gst/mpegtsdemux/mpegtsbase.c
@@ -93,6 +93,8 @@ static gboolean mpegts_base_get_tags_from_eit (MpegTSBase * base,
     GstMpegtsSection * section);
 static gboolean mpegts_base_parse_atsc_mgt (MpegTSBase * base,
     GstMpegtsSection * section);
+static gboolean mpegts_base_parse_scte_splice (MpegTSBase *base,
+    GstMpegtsSection *section);
 static gboolean remove_each_program (gpointer key, MpegTSBaseProgram * program,
     MpegTSBase * base);
 
@@ -141,7 +143,6 @@ mpegts_base_class_init (MpegTSBaseClass * klass)
       g_param_spec_boolean ("parse-private-sections", "Parse private sections",
           "Parse private sections", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-
   klass->sink_query = GST_DEBUG_FUNCPTR (mpegts_base_default_sink_query);
 }
 
@@ -155,6 +156,7 @@ mpegts_base_set_property (GObject * object, guint prop_id,
     case PROP_PARSE_PRIVATE_SECTIONS:
       base->parse_private_sections = g_value_get_boolean (value);
       break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
   }
@@ -249,7 +251,7 @@ mpegts_base_init (MpegTSBase * base)
 
   base->push_data = TRUE;
   base->push_section = TRUE;
-
+  base->base_offset = 0;
   mpegts_base_reset (base);
 }
 
@@ -440,6 +442,19 @@ mpegts_base_get_program (MpegTSBase * base, gint program_number)
   return program;
 }
 
+MpegTSBaseProgram*
+mpegts_base_get_program_from_pid(MpegTSBase *base, gint pid)
+{
+    GHashTableIter iter;
+    gpointer key, value;
+    g_hash_table_iter_init(&iter, base->programs);
+    while (g_hash_table_iter_next(&iter, &key, &value))
+    {
+        if (((MpegTSBaseProgram*)value)->active && ((MpegTSBaseProgram*)value)->streams[pid])
+            return (MpegTSBaseProgram*)value;
+    }
+    return NULL;
+}
 static MpegTSBaseProgram *
 mpegts_base_steal_program (MpegTSBase * base, gint program_number)
 {
@@ -473,6 +488,7 @@ mpegts_base_free_program (MpegTSBaseProgram * program)
   if (program->pmt) {
     gst_mpegts_section_unref (program->section);
     program->pmt = NULL;
+    program->spliceinfo = NULL;
   }
 
   /* FIXME FIXME FIXME FREE STREAM OBJECT ! */
@@ -562,7 +578,8 @@ mpegts_base_program_add_stream (MpegTSBase * base,
     GST_DEBUG ("PID 0x%04x, registration_id %" SAFE_FOURCC_FORMAT,
         bstream->pid, SAFE_FOURCC_ARGS (bstream->registration_id));
   }
-
+  bstream->already_spliced = FALSE;
+  bstream->cc = 0;
   program->streams[pid] = bstream;
   program->stream_list = g_list_append (program->stream_list, bstream);
 
@@ -708,6 +725,7 @@ _stream_is_private_section (GstMpegtsPMTStream * stream)
     case GST_MPEGTS_STREAM_TYPE_DSMCC_D:
     case GST_MPEGTS_STREAM_TYPE_SL_FLEXMUX_SECTIONS:
     case GST_MPEGTS_STREAM_TYPE_METADATA_SECTIONS:
+    case GST_MPEGTS_STREAM_TYPE_SCTE_SPLICING:
       /* known PSI streams */
       return TRUE;
     default:
@@ -898,6 +916,7 @@ mpegts_base_activate_program (MpegTSBase * base, MpegTSBaseProgram * program,
   program->pmt = pmt;
   program->pmt_pid = pmt_pid;
   program->pcr_pid = pmt->pcr_pid;
+  program->spliceinfo = NULL;
 
   /* extract top-level registration_id if present */
   program->registration_id =
@@ -953,7 +972,7 @@ mpegts_base_apply_pat (MpegTSBase * base, GstMpegtsSection * section)
   if (G_UNLIKELY (pat == NULL))
     return FALSE;
 
-  GST_INFO_OBJECT (base, "PAT");
+  GST_DEBUG_OBJECT (base, "PAT");
 
   /* Applying a new PAT does two things:
    * * It adds the new programs to the list of programs this element handles
@@ -965,6 +984,7 @@ mpegts_base_apply_pat (MpegTSBase * base, GstMpegtsSection * section)
 
   old_pat = base->pat;
   base->pat = pat;
+  base->ts_id = section->subtable_extension;
 
   GST_LOG ("Activating new Program Association Table");
   /* activate the new table */
@@ -1153,8 +1173,8 @@ mpegts_base_handle_psi (MpegTSBase * base, GstMpegtsSection * section)
 {
   gboolean post_message = TRUE;
 
-  GST_DEBUG ("Handling PSI (pid: 0x%04x , table_id: 0x%02x)",
-      section->pid, section->table_id);
+  GST_DEBUG ("Handling PSI (pid: 0x%04x , table_id: 0x%02x, section_type:%02x)",
+      section->pid, section->table_id,section->section_type);
 
   switch (section->section_type) {
     case GST_MPEGTS_SECTION_PAT:
@@ -1176,6 +1196,11 @@ mpegts_base_handle_psi (MpegTSBase * base, GstMpegtsSection * section)
     case GST_MPEGTS_SECTION_ATSC_MGT:
       post_message = mpegts_base_parse_atsc_mgt (base, section);
       break;
+    case GST_MPEGTS_SECTION_SCTE_SPLICING:
+      GST_DEBUG("Found splicing table.");
+      GST_MEMDUMP ("Full section data", section->data,section->section_length);
+      post_message = mpegts_base_parse_scte_splice(base,section);
+      break;  
     default:
       break;
   }
@@ -1212,6 +1237,20 @@ mpegts_base_parse_atsc_mgt (MpegTSBase * base, GstMpegtsSection * section)
 }
 
 static gboolean
+mpegts_base_parse_scte_splice(MpegTSBase *base, GstMpegtsSection *section)
+{
+  const GstMpegtsScteSpliceInfo *sinfo;
+
+  sinfo=gst_mpegts_section_get_scte_splice_info(section);
+  if(G_UNLIKELY(sinfo==NULL))
+    return FALSE;
+  if(G_UNLIKELY(mpegts_base_get_program_from_pid(base, section->pid)==NULL))
+    return FALSE;
+  mpegts_base_get_program_from_pid(base, section->pid)->spliceinfo = sinfo;
+  return TRUE;
+}
+
+static gboolean
 mpegts_base_get_tags_from_eit (MpegTSBase * base, GstMpegtsSection * section)
 {
   const GstMpegtsEIT *eit;
@@ -1321,7 +1360,7 @@ mpegts_base_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_SEGMENT:
       gst_event_copy_segment (event, &base->segment);
-      GST_DEBUG_OBJECT (base, "Received segment %" GST_SEGMENT_FORMAT,
+      GST_INFO_OBJECT (base, "Received segment %" GST_SEGMENT_FORMAT,
           &base->segment);
       /* Check if we need to switch PCR/PTS handling */
       if (base->segment.format == GST_FORMAT_TIME) {
@@ -1388,6 +1427,7 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   MpegTSPacketizer2 *packetizer;
   MpegTSPacketizerPacket packet;
   MpegTSBaseClass *klass;
+  static prev_offset;
 
   base = GST_MPEGTS_BASE (parent);
   klass = GST_MPEGTS_BASE_GET_CLASS (base);
@@ -1415,6 +1455,15 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
       mpegts_packetizer_flush (base->packetizer, FALSE);
   }
 
+  if (GST_BUFFER_OFFSET(buf) < prev_offset) {
+      base->base_offset = prev_offset;
+      GST_DEBUG_OBJECT(base, "New input file, flattening offsets.");
+  }
+  prev_offset = GST_BUFFER_OFFSET_END(buf);
+  
+  GST_BUFFER_OFFSET(buf) += base->base_offset;
+  GST_BUFFER_OFFSET_END(buf) += base->base_offset;
+
   mpegts_packetizer_push (base->packetizer, buf);
 
   while (res == GST_FLOW_OK) {
diff --git a/gst/mpegtsdemux/mpegtsbase.h b/gst/mpegtsdemux/mpegtsbase.h
index 5775cdd..d9eeccb 100644
--- a/gst/mpegtsdemux/mpegtsbase.h
+++ b/gst/mpegtsdemux/mpegtsbase.h
@@ -32,6 +32,7 @@
 
 #include <gst/gst.h>
 #include "mpegtspacketizer.h"
+#include <gst/mpegts/mpegts.h>
 
 G_BEGIN_DECLS
 
@@ -66,6 +67,8 @@ struct _MpegTSBaseStream
   GstMpegtsPMTStream *stream;
   GstStream          *stream_object;
   gchar              *stream_id;
+  gboolean already_spliced;
+  guint8 cc;
 };
 
 struct _MpegTSBaseProgram
@@ -73,13 +76,15 @@ struct _MpegTSBaseProgram
   gint                program_number;
   guint16             pmt_pid;
   guint16             pcr_pid;
+  guint8              pmt_cc;
+  guint8              pat_cc;
 
   /* Content of the registration descriptor (if present) */
   guint32             registration_id;
 
   GstMpegtsSection   *section;
   const GstMpegtsPMT *pmt;
-
+  const GstMpegtsScteSpliceInfo *spliceinfo;
   MpegTSBaseStream  **streams;
   GList              *stream_list;
   gint                patcount;
@@ -125,6 +130,7 @@ struct _MpegTSBase {
   GHashTable *programs;
 
   GPtrArray  *pat;
+  guint16 ts_id;
   MpegTSPacketizer2 *packetizer;
 
   /* arrays that say whether a pid is a known psi pid or a pes pid */
@@ -161,6 +167,8 @@ struct _MpegTSBase {
   /* Whether the parent bin is streams-aware, meaning we can
    * add/remove streams at any point in time */
   gboolean streams_aware;
+
+  guint64 base_offset;
 };
 
 struct _MpegTSBaseClass {
diff --git a/gst/mpegtsdemux/mpegtspacketizer.c b/gst/mpegtsdemux/mpegtspacketizer.c
index aebc688..1dd382e 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.c
+++ b/gst/mpegtsdemux/mpegtspacketizer.c
@@ -45,23 +45,18 @@ G_DEFINE_TYPE_EXTENDED (MpegTSPacketizer2, mpegts_packetizer, G_TYPE_OBJECT, 0,
 
 #define ABSDIFF(a,b) ((a) < (b) ? (b) - (a) : (a) - (b))
 
-#define PACKETIZER_GROUP_LOCK(p) g_mutex_lock(&((p)->group_lock))
-#define PACKETIZER_GROUP_UNLOCK(p) g_mutex_unlock(&((p)->group_lock))
 
 static void mpegts_packetizer_dispose (GObject * object);
 static void mpegts_packetizer_finalize (GObject * object);
-static GstClockTime calculate_skew (MpegTSPacketizer2 * packetizer,
-    MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time);
 static void _close_current_group (MpegTSPCR * pcrtable);
-static void record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
-    guint64 pcr, guint64 offset);
+
 
 #define CONTINUITY_UNSET 255
 #define VERSION_NUMBER_UNSET 255
 #define TABLE_ID_UNSET 0xFF
 #define PACKET_SYNC_BYTE 0x47
 
-static inline MpegTSPCR *
+MpegTSPCR *
 get_pcr_table (MpegTSPacketizer2 * packetizer, guint16 pid)
 {
   MpegTSPCR *res;
@@ -175,7 +170,8 @@ seen_section_before (MpegTSPacketizerStream * stream, guint8 table_id,
     return FALSE;
   }
   /* Finally return whether we saw that section or not */
-  return MPEGTS_BIT_IS_SET (subtable->seen_section, section_number);
+//  return MPEGTS_BIT_IS_SET (subtable->seen_section, section_number);
+  return FALSE;
 }
 
 static MpegTSPacketizerStreamSubtable *
@@ -469,8 +465,9 @@ mpegts_packetizer_parse_packet (MpegTSPacketizer2 * packetizer,
 
   packet->scram_afc_cc = tmp = *data++;
   /* transport_scrambling_control 2 */
+  /* FIXME: pass-through scrambled packets.
   if (G_UNLIKELY (tmp & 0xc0))
-    return PACKET_BAD;
+    return PACKET_BAD;   */
 
   packet->data = data;
 
@@ -1089,8 +1086,8 @@ section_start:
   /* Fast path for short packets */
   if (!long_packet) {
     /* We can create the section now (function will check for size) */
-    GST_DEBUG ("Short packet");
-    section_length = (GST_READ_UINT16_BE (data + 1) & 0xfff) + 3;
+   section_length = (GST_READ_UINT16_BE (data + 1) & 0xfff) + 3;
+   GST_DEBUG ("Short packet with length: %i bytes",section_length);
     /* Only do fast-path if we have enough byte */
     if (section_length < packet->data_end - data) {
       if ((section =
@@ -1304,7 +1301,7 @@ mpegts_packetizer_resync (MpegTSPCR * pcr, GstClockTime time,
  *
  * Returns: @time adjusted with the clock skew.
  */
-static GstClockTime
+GstClockTime
 calculate_skew (MpegTSPacketizer2 * packetizer,
     MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time)
 {
@@ -1323,13 +1320,13 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pcr->base_time))) {
     pcr->base_time = time;
     pcr->prev_out_time = GST_CLOCK_TIME_NONE;
-    GST_DEBUG ("Taking new base time %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
+    GST_INFO ("Taking new base time %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
   }
 
   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pcr->base_pcrtime))) {
     pcr->base_pcrtime = gstpcrtime;
     pcr->prev_send_diff = -1;
-    GST_DEBUG ("Taking new base pcrtime %" GST_TIME_FORMAT,
+    GST_INFO ("Taking new base pcrtime %" GST_TIME_FORMAT,
         GST_TIME_ARGS (gstpcrtime));
   }
 
@@ -1338,7 +1335,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
       gstpcrtime < pcr->last_pcrtime) {
     if (pcr->last_pcrtime - gstpcrtime > PCR_GST_MAX_VALUE / 2) {
       /* PCR wraparound */
-      GST_DEBUG ("PCR wrap");
+      GST_INFO ("PCR wrap");
       pcr->pcroffset += PCR_GST_MAX_VALUE;
       gstpcrtime = PCRTIME_TO_GSTTIME (pcrtime) + pcr->pcroffset;
       send_diff = gstpcrtime - pcr->base_pcrtime;
@@ -1346,7 +1343,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
         && pcr->last_pcrtime - gstpcrtime > 15 * GST_SECOND) {
       /* Time jumped backward by > 15 seconds, and we have a timestamp
        * to use to close the discont. Assume a reset */
-      GST_DEBUG ("PCR reset");
+      GST_INFO ("PCR reset");
       /* Calculate PCR we would have expected for the given input time,
        * essentially applying the reverse correction process
        *
@@ -1368,7 +1365,7 @@ calculate_skew (MpegTSPacketizer2 * packetizer,
       pcr->pcroffset += time - pcr->base_time + pcr->base_pcrtime - gstpcrtime;
       gstpcrtime = PCRTIME_TO_GSTTIME (pcrtime) + pcr->pcroffset;
       send_diff = gstpcrtime - pcr->base_pcrtime;
-      GST_DEBUG ("Introduced offset is now %" GST_TIME_FORMAT
+      GST_INFO ("Introduced offset is now %" GST_TIME_FORMAT
           " corrected pcr time %" GST_TIME_FORMAT,
           GST_TIME_ARGS (pcr->pcroffset), GST_TIME_ARGS (gstpcrtime));
     } else {
@@ -1920,7 +1917,7 @@ _close_current_group (MpegTSPCR * pcrtable)
   /* And re-evaluate all groups */
 }
 
-static void
+void
 record_pcr (MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
     guint64 pcr, guint64 offset)
 {
@@ -2335,7 +2332,7 @@ mpegts_packetizer_pts_to_ts (MpegTSPacketizer2 * packetizer,
 
   PACKETIZER_GROUP_UNLOCK (packetizer);
 
-  GST_DEBUG ("Returning timestamp %" GST_TIME_FORMAT " for pts %"
+  GST_INFO ("Returning timestamp %" GST_TIME_FORMAT " for pts %"
       GST_TIME_FORMAT " pcr_pid:0x%04x", GST_TIME_ARGS (res),
       GST_TIME_ARGS (pts), pcr_pid);
   return res;
diff --git a/gst/mpegtsdemux/mpegtspacketizer.h b/gst/mpegtsdemux/mpegtspacketizer.h
index 0cf83a6..1a9b43b 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.h
+++ b/gst/mpegtsdemux/mpegtspacketizer.h
@@ -328,6 +328,15 @@ typedef struct
 #define MPEGTS_BIT_SET(field, offs)    ((field)[(offs) >> 3] |=  (1 << ((offs) & 0x7)))
 #define MPEGTS_BIT_UNSET(field, offs)  ((field)[(offs) >> 3] &= ~(1 << ((offs) & 0x7)))
 #define MPEGTS_BIT_IS_SET(field, offs) ((field)[(offs) >> 3] &   (1 << ((offs) & 0x7)))
+#define PACKETIZER_GROUP_LOCK(p) g_mutex_lock(&((p)->group_lock))
+#define PACKETIZER_GROUP_UNLOCK(p) g_mutex_unlock(&((p)->group_lock))
+
+GstClockTime calculate_skew(MpegTSPacketizer2 * packetizer,
+    MpegTSPCR * pcr, guint64 pcrtime, GstClockTime time);
+void record_pcr(MpegTSPacketizer2 * packetizer, MpegTSPCR * pcrtable,
+    guint64 pcr, guint64 offset);
+MpegTSPCR *
+get_pcr_table(MpegTSPacketizer2 * packetizer, guint16 pid);
 
 typedef enum {
   PACKET_BAD       = FALSE,
diff --git a/gst/mpegtsdemux/mpegtsparse.c b/gst/mpegtsdemux/mpegtsparse.c
index 8e227ba..fb31675 100644
--- a/gst/mpegtsdemux/mpegtsparse.c
+++ b/gst/mpegtsdemux/mpegtsparse.c
@@ -33,6 +33,8 @@
 #include "mpegtsbase.h"
 #include "mpegtsparse.h"
 #include "gstmpegdesc.h"
+#include "pesparse.h"
+#include <gst/video/video.h>
 
 /* latency in mseconds is maximum 100 ms between PCR */
 #define TS_LATENCY 100
@@ -45,6 +47,41 @@ GST_DEBUG_CATEGORY_STATIC (mpegts_parse_debug);
 
 typedef struct _MpegTSParsePad MpegTSParsePad;
 
+static guint8 unham84tab[256] = {
+    0x01, 0xff, 0x01, 0x01, 0xff, 0x00, 0x01, 0xff,
+    0xff, 0x02, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x07,
+    0xff, 0x00, 0x01, 0xff, 0x00, 0x80, 0xff, 0x00,
+    0x06, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x03, 0xff,
+    0xff, 0x0c, 0x01, 0xff, 0x04, 0xff, 0xff, 0x07,
+    0x06, 0xff, 0xff, 0x07, 0xff, 0x07, 0x07, 0x87,
+    0x06, 0xff, 0xff, 0x05, 0xff, 0x00, 0x0d, 0xff,
+    0x86, 0x06, 0x06, 0xff, 0x06, 0xff, 0xff, 0x07,
+    0xff, 0x02, 0x01, 0xff, 0x04, 0xff, 0xff, 0x09,
+    0x02, 0x82, 0xff, 0x02, 0xff, 0x02, 0x03, 0xff,
+    0x08, 0xff, 0xff, 0x05, 0xff, 0x00, 0x03, 0xff,
+    0xff, 0x02, 0x03, 0xff, 0x03, 0xff, 0x83, 0x03,
+    0x04, 0xff, 0xff, 0x05, 0x84, 0x04, 0x04, 0xff,
+    0xff, 0x02, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x07,
+    0xff, 0x05, 0x05, 0x85, 0x04, 0xff, 0xff, 0x05,
+    0x06, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x03, 0xff,
+    0xff, 0x0c, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x09,
+    0x0a, 0xff, 0xff, 0x0b, 0x8a, 0x0a, 0x0a, 0xff,
+    0x08, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x0d, 0xff,
+    0xff, 0x0b, 0x0b, 0x8b, 0x0a, 0xff, 0xff, 0x0b,
+    0x0c, 0x8c, 0xff, 0x0c, 0xff, 0x0c, 0x0d, 0xff,
+    0xff, 0x0c, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x07,
+    0xff, 0x0c, 0x0d, 0xff, 0x0d, 0xff, 0x8d, 0x0d,
+    0x06, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x0d, 0xff,
+    0x08, 0xff, 0xff, 0x09, 0xff, 0x09, 0x09, 0x89,
+    0xff, 0x02, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x09,
+    0x88, 0x08, 0x08, 0xff, 0x08, 0xff, 0xff, 0x09,
+    0x08, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x03, 0xff,
+    0xff, 0x0c, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x09,
+    0x0f, 0xff, 0x8f, 0x0f, 0xff, 0x0e, 0x0f, 0xff,
+    0x08, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x0d, 0xff,
+    0xff, 0x0e, 0x0f, 0xff, 0x0e, 0x8e, 0xff, 0x0e,
+};
+
 typedef struct
 {
   MpegTSBaseProgram program;
@@ -58,12 +95,18 @@ struct _MpegTSParsePad
   /* the program number that the peer wants on this pad */
   gint program_number;
   MpegTSParseProgram *program;
+  GstClockTime last_splice_ts;
 
   /* set to FALSE before a push and TRUE after */
   gboolean pushed;
 
   /* the return of the latest push */
   GstFlowReturn flow_return;
+  GstBuffer *pending_packets;
+  GstBuffer *spliced_packets;
+  gboolean has_pat, has_pmt;
+  gboolean splicing_inprogress;
+  GstMemory *pat, *pmt;
 };
 
 static GstStaticPadTemplate src_template =
@@ -84,6 +127,7 @@ enum
   PROP_SET_TIMESTAMPS,
   PROP_SMOOTHING_LATENCY,
   PROP_PCR_PID,
+  PROP_SCTE35_INSERT
   /* FILL ME */
 };
 
@@ -159,6 +203,10 @@ mpegts_parse_class_init (MpegTSParse2Class * klass)
       g_param_spec_int ("pcr-pid", "PID containing PCR",
           "Set the PID to use for PCR values (-1 for auto)",
           -1, G_MAXINT, -1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property(gobject_class, PROP_SCTE35_INSERT,
+      g_param_spec_boxed("scte35-insert", "SCTE35 insert",
+          "A GstStructure to set an SCTE35 Insert command", GST_TYPE_STRUCTURE,
+          G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
 
   element_class = GST_ELEMENT_CLASS (klass);
   element_class->pad_removed = mpegts_parse_pad_removed;
@@ -169,7 +217,7 @@ mpegts_parse_class_init (MpegTSParse2Class * klass)
   gst_element_class_add_static_pad_template (element_class, &program_template);
 
   gst_element_class_set_static_metadata (element_class,
-      "MPEG transport stream parser", "Codec/Parser",
+      "MPEG transport stream parser - with duration", "Codec/Parser",
       "Parses MPEG2 transport streams",
       "Alessandro Decina <alessandro@nnva.org>, "
       "Zaheer Abbas Merali <zaheerabbas at merali dot org>");
@@ -270,6 +318,20 @@ mpegts_parse_set_property (GObject * object, guint prop_id,
     case PROP_PCR_PID:
       parse->pcr_pid = parse->user_pcr_pid = g_value_get_int (value);
       break;
+    case PROP_SCTE35_INSERT: {
+        const GstStructure *s = gst_value_get_structure(value);
+        guint program_number;
+        gst_structure_get_uint(s, "program-number", &program_number);
+        MpegTSBaseProgram *program = mpegts_base_get_program(&parse->parent, program_number);
+        if (program->spliceinfo != NULL) {
+            g_slice_free(GstMpegtsScteSpliceInfo, program->spliceinfo);
+            program->spliceinfo = NULL; // FIXME: We probably need a better code to free the allocated memory!!!
+        }
+        program->spliceinfo = gst_mpegts_set_scte_splice_info(s);
+        GST_DEBUG_OBJECT(parse, "Splice insert created from stucture.");
+        break;
+    }
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
   }
@@ -389,7 +451,31 @@ push_event (MpegTSBase * base, GstEvent * event)
 
   return TRUE;
 }
-
+static gboolean 
+mpegts_parse_srcpad_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    gboolean res = TRUE;
+    MpegTSParse2 *parse = GST_MPEGTS_PARSE(parent);
+    GST_INFO_OBJECT(parse, "Got event %s",
+        gst_event_type_get_name(GST_EVENT_TYPE(event)));
+
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_CUSTOM_UPSTREAM:
+        if (gst_video_event_is_force_key_unit(event)) {
+            GstClockTime timestamp, stream_time, running_time;
+            gboolean all_headers;
+            guint count;
+            gst_video_event_parse_upstream_force_key_unit(event, &running_time, &all_headers, &count);
+            GST_INFO_OBJECT(parse, "received upstream force key unit event, "
+                "seqnum %d running_time %" GST_TIME_FORMAT
+                " all_headers %d count %d", gst_event_get_seqnum(event),
+                GST_TIME_ARGS(running_time), all_headers, count);
+        }
+    default:
+        res = gst_pad_event_default(pad, parent, event);
+    }
+    return res;
+}
 static MpegTSParsePad *
 mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
 {
@@ -399,6 +485,8 @@ mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
   pad = gst_pad_new_from_static_template (&program_template, pad_name);
   gst_pad_set_query_function (pad,
       GST_DEBUG_FUNCPTR (mpegts_parse_src_pad_query));
+  gst_pad_set_event_function(pad,
+      GST_DEBUG_FUNCPTR(mpegts_parse_srcpad_event));
 
   /* create our wrapper */
   tspad = g_new0 (MpegTSParsePad, 1);
@@ -407,6 +495,12 @@ mpegts_parse_create_tspad (MpegTSParse2 * parse, const gchar * pad_name)
   tspad->program = NULL;
   tspad->pushed = FALSE;
   tspad->flow_return = GST_FLOW_NOT_LINKED;
+  tspad->pending_packets = NULL;
+  tspad->spliced_packets = NULL;
+  tspad->has_pat = FALSE;
+  tspad->has_pmt = FALSE;
+  tspad->splicing_inprogress = FALSE;
+  tspad->last_splice_ts = GST_CLOCK_TIME_NONE;
   gst_pad_set_element_private (pad, tspad);
   gst_flow_combiner_add_pad (parse->flowcombiner, pad);
 
@@ -507,6 +601,12 @@ mpegts_parse_request_new_pad (GstElement * element, GstPadTemplate * template,
     gst_event_set_group_id (event, parse->group_id);
 
   gst_pad_push_event (pad, event);
+
+  GstSegment seg;
+  gst_segment_init(&seg, GST_FORMAT_TIME);
+  GST_DEBUG_OBJECT(parse,
+      "Generating time output segment %" GST_SEGMENT_FORMAT, &seg);
+  gst_pad_push_event(pad, gst_event_new_segment(&seg));
   g_free (stream_id);
 
   gst_element_add_pad (element, pad);
@@ -525,6 +625,435 @@ mpegts_parse_release_pad (GstElement * element, GstPad * pad)
   gst_element_remove_pad (element, pad);
 }
 
+gboolean
+mpegts_parse_tspad_pid_spliced(MpegTSParsePad *tspad, guint16 pid)
+{
+    if (tspad->program->program.streams[pid] == NULL)
+        return TRUE;
+    switch (tspad->program->program.streams[pid]->stream_type) {
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG1:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG1:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG2:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_H264:
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_CLEAN:
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC:
+        return tspad->program->program.streams[pid]->already_spliced;
+    default:
+        return TRUE;
+    }
+}
+
+gboolean
+mpegts_parse_tspad_all_streams_spliced(MpegTSParsePad *tspad, guint16 pid)
+{
+    GList *streams, *s;
+    gboolean res = TRUE;
+    if(tspad->program->program.stream_list == NULL)
+        return FALSE;
+    for (s = tspad->program->program.stream_list; s != NULL; s = s->next) {
+        MpegTSBaseStream *stream = (MpegTSBaseStream*)s->data;
+        switch (stream->stream_type) {
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG1:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG1:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG2:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_H264:
+        case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_CLEAN:
+        case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC:
+            res &=stream->already_spliced;
+        }
+    }
+    return res;
+}
+
+static void
+stream_clear_spliced_flag(MpegTSBaseStream *stream, gpointer user_data)
+{
+    stream->already_spliced = FALSE;
+}
+
+static gboolean
+set_packet_discontinuity_flag(MpegTSParse2 *parse, MpegTSPacketizerPacket *packet) 
+{
+    if (packet->scram_afc_cc & 0x20) {
+        //FIXME:If adaptation field length is 0; this will fail!!!
+        GST_DEBUG_OBJECT(parse, "Setting packet discountinuity flag to 1 on PID:%04x.",packet->pid);
+        packet->data_start[5] |= 0x80;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static gboolean
+set_packet_cc(MpegTSParse2 * parse, MpegTSParsePad *tspad, MpegTSPacketizerPacket *packet)
+{
+    if (tspad->program != NULL) {
+        if (tspad->program->program.streams[packet->pid] != NULL && MPEGTS_BIT_IS_SET(parse->parent.is_pes, packet->pid)) {
+            packet->scram_afc_cc &= 0xf0;
+            if (((packet->scram_afc_cc & 0x30 )== 0) || ((packet->scram_afc_cc & 0x30) == 0x20)) {
+                packet->scram_afc_cc |= tspad->program->program.streams[packet->pid]->cc % 16;
+                GST_LOG_OBJECT(parse, "PID:%i AFC:0x%x CC not increased.", packet->pid, packet->scram_afc_cc);
+            }
+            else {
+                packet->scram_afc_cc |= ++tspad->program->program.streams[packet->pid]->cc % 16;
+            }
+            packet->data_start[3] = packet->scram_afc_cc;
+            GST_LOG_OBJECT(parse, "Increase CC for PID:0x%0x in Stream:%s", packet->pid, tspad->program->program.streams[packet->pid]->stream_id);
+            return TRUE;
+        } else if (packet->pid == 0) {
+            packet->scram_afc_cc &= 0xf0;
+            packet->scram_afc_cc |= ++tspad->program->program.pat_cc % 16;
+            packet->data_start[3] = packet->scram_afc_cc;
+        }
+        else if (packet->pid == tspad->program->program.pmt_pid) {
+            packet->scram_afc_cc &= 0xf0;
+            packet->scram_afc_cc |= ++tspad->program->program.pmt_cc % 16;
+            packet->data_start[3] = packet->scram_afc_cc;
+        }
+    }
+    return FALSE;
+}
+
+static void
+mpegts_parse_tspad_insert_adaptation_field_with_discontinuity_flag(MpegTSParse2 *parse, MpegTSParsePad *tspad, guint16 pid,GstBuffer *buf) {
+    GstMemory *mem = gst_allocator_alloc(NULL, 188, NULL);
+    GstMapInfo info;
+    gst_memory_map(mem, &info, GST_MAP_WRITE);
+    memset(info.data, 0xff, 188);
+    info.data[0] = 0x47;
+    info.data[1] = (pid & 0x1fff) >> 8;
+    info.data[2] = (pid & 0x00ff);
+    info.data[3] = 0x20 | (tspad->program->program.streams[pid]->cc % 16);
+    info.data[4] = 188 - 5;
+    info.data[5] = 0x80;
+    gst_memory_unmap(mem, &info);
+    gst_buffer_append_memory(buf, mem);
+    GST_LOG_OBJECT(parse, "Adaptation only packet for PID:%i is appended with discountinuity flag.", pid);
+}
+
+static GstFlowReturn
+mpegts_parse_tspad_queue_packet(MpegTSParse2 * parse, MpegTSParsePad * 
+    tspad, MpegTSPacketizerPacket * packet, GstMpegtsSection * section)
+{
+    GstFlowReturn ret = GST_FLOW_OK;
+    PESParsingResult res;
+    GstMapInfo info;
+    MpegTSPacketizerStream *stream;
+    PESHeader pes;
+    gboolean ad_hoc_splice = FALSE;
+    gboolean all_streams_spliced = FALSE;
+    GstBuffer *actual_buffer;
+    guint16 splice_event_id;
+    static gint8 splice_event_index;
+    static guint memory_counter;
+
+    GstClockTime current_timestamp = GST_CLOCK_TIME_NONE;
+    guint8* txt_payload;
+
+    GST_LOG_OBJECT(parse, "Program:%i PID:0x%04x afc:0x%04x, pusi:%i, size:%i", 
+        tspad->program_number, packet->pid, packet->scram_afc_cc,
+        packet->payload_unit_start_indicator,packet->data_end-packet->data_start);
+
+    GstMemory *mem = gst_allocator_alloc(NULL, packet->data_end - packet->data_start, NULL);
+    
+    /* Search for X31 teletext packets */
+    if (parse->parent.parse_private_sections == TRUE && MPEGTS_BIT_IS_SET(parse->parent.is_pes, packet->pid)) {
+        if (tspad->program->program.streams[packet->pid]->stream_type == GST_MPEGTS_STREAM_TYPE_PRIVATE_PES_PACKETS) {
+            if (packet->payload_unit_start_indicator) {
+                if (mpegts_parse_pes_header(packet->payload, packet->data_end - packet->payload, &pes) == PES_PARSING_OK) {
+                    txt_payload = packet->payload + pes.header_size;
+                    GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i header length:%i data_identifier:%x",
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), pes.packet_length, pes.header_size, *txt_payload);
+                    if (*txt_payload++ > 0x10 ) { //data_identifier: EBU data EN 300 472 (teletext) Can be anything???
+                        GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i data_unit_id:0x%x",
+                            GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), *(txt_payload+1),*txt_payload);
+                        while (txt_payload < packet->data_end) {
+                            if (*txt_payload == 0x02 || *txt_payload == 0x03) { //data_unit_id: EBU Teletext non-subtitle data or subtitle data
+                                guint8 c1, c2, c;
+                                guint8 magazine, packet_nr;
+                                static guint gpis;
+                                c1 = unham84tab[*(txt_payload+4)];
+                                c2 = unham84tab[*(txt_payload+5)];
+                                c = (c2 << 4) | (c1 & 0x0f);
+                                packet_nr = (c >> 3) & 0x1f;
+                                magazine = c & 0x07;
+                                GST_LOG_OBJECT(parse, "Teletext packet detected at %" GST_TIME_FORMAT " packet length:%i data_unit_id:%x packet:0x%0x magazine:0x%0x",
+                                    GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), *(txt_payload + 1), *txt_payload,packet_nr,magazine);
+                                if (packet_nr == 31) { //We have an X31 packet!!!!
+                                    if (*(txt_payload+11) != gpis) {
+                                        gpis = *(txt_payload+11);
+                                        GST_INFO_OBJECT(parse, "X31 packet detected at %" GST_TIME_FORMAT " with different GPIs:0x%x",
+                                            GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)), gpis);
+                                        gst_element_post_message(GST_ELEMENT(&parse->parent.element),
+                                            gst_message_new_element(GST_OBJECT(&parse->parent.element),
+                                                gst_structure_new("x31-received",
+                                                    "PTS", G_TYPE_UINT64, pes.PTS,
+                                                    "GPI", G_TYPE_UINT, gpis, NULL)));
+                                        GstEvent *x31event;
+                                        x31event = gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM,
+                                            gst_structure_new("x31-received",
+                                                "PTS", G_TYPE_UINT64, pes.PTS,
+                                                "GPI", G_TYPE_UINT, gpis, NULL));
+                                        gst_pad_push_event(tspad->pad, x31event);
+
+                                    }
+                                    GST_LOG_OBJECT(parse, "X31 packet detected at %" GST_TIME_FORMAT " with GPI:0x%x native: 0x%0x 0x%0x",
+                                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)),c,*(txt_payload+11),*(txt_payload+12));
+                                }
+
+                            }
+                            txt_payload += *(txt_payload+1); //Move to the next txt packet in the TS packet payload
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    if (packet->afc_flags & 0x10) {
+        //Have a PCR in the packet, let's convert it to buffer timestamp.
+        if (packet->afc_flags & 0x80) { 
+            //We have discontinuity flag set. Let's set a few things....black magic needs more understanding!!!!
+            MpegTSPacketizer2 *packetizer = parse->parent.packetizer;
+            MpegTSPCR *pcrtable = NULL;
+            PACKETIZER_GROUP_LOCK(packetizer);
+       /*     if (packetizer->calculate_skew
+                && GST_CLOCK_TIME_IS_VALID(packetizer->last_in_time)) {
+                pcrtable = get_pcr_table(packetizer, packet->pid);
+                calculate_skew(packetizer, pcrtable, packet->pcr,
+                    GST_BUFFER_PTS(tspad->pending_packets)+GST_BUFFER_DURATION(tspad->pending_packets));
+            }
+            if (packetizer->calculate_offset) {
+                if (!pcrtable)
+                    pcrtable = get_pcr_table(packetizer, packet->pid);
+                record_pcr(packetizer, pcrtable, packet->pcr, packet->offset);
+            } */
+            packetizer->last_in_time = GST_BUFFER_PTS(tspad->pending_packets) + GST_BUFFER_DURATION(tspad->pending_packets);
+            current_timestamp= GST_BUFFER_PTS(tspad->pending_packets) + GST_BUFFER_DURATION(tspad->pending_packets);
+            PACKETIZER_GROUP_UNLOCK(packetizer);
+        }
+        else {
+            current_timestamp = mpegts_packetizer_pts_to_ts(parse->parent.packetizer, PCRTIME_TO_GSTTIME(packet->pcr), packet->pid);
+        }
+    }
+
+    if ((packet->afc_flags & 0x10) && (tspad->last_splice_ts==GST_CLOCK_TIME_NONE)) { 
+        //packet has PCR and probably the first PCR we found. Send segment event.
+        tspad->last_splice_ts = current_timestamp;
+        GstSegment seg;
+        gst_segment_init(&seg, GST_FORMAT_TIME);
+        seg.start = current_timestamp;
+        GST_INFO_OBJECT(parse,
+            "First packet. Generating time output segment %" GST_SEGMENT_FORMAT, &seg);
+        gst_pad_push_event(tspad->pad, gst_event_new_segment(&seg));
+
+    }
+
+    if (tspad->splicing_inprogress == TRUE) {
+        if (mpegts_parse_tspad_pid_spliced(tspad, packet->pid)==FALSE && packet->payload_unit_start_indicator==64) {
+            if (mpegts_parse_pes_header(packet->payload, packet->data_end - packet->payload, &pes) == PES_PARSING_OK) {
+                GST_DEBUG_OBJECT(parse, "PES header parsed with result PES_PARSING_OK; PID:0x%04x, PTS:%" GST_TIME_FORMAT, packet->pid,GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+                if (tspad->program->program.spliceinfo != NULL) {
+                    GST_DEBUG_OBJECT(parse, "Splice event exists. PTS:%"GST_TIME_FORMAT " Offset:%" GST_TIME_FORMAT,
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->splice_insert.pts_time)),
+                        GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->pts_adjustment)));
+                    if (tspad->program->program.spliceinfo->splice_insert.pts_time < pes.PTS) {
+                        tspad->program->program.streams[packet->pid]->already_spliced = TRUE;
+                        //Audio packets doesn't have adaptation field even at audio frame boundaries. Let's insert a full packet.
+                        mpegts_parse_tspad_insert_adaptation_field_with_discontinuity_flag(parse, tspad, packet->pid, tspad->spliced_packets);
+
+                    }
+                }
+            }
+            else {
+                GST_WARNING_OBJECT(parse, "Failed to parse PES header for PID:%i", packet->pid);
+            }
+        }
+    }
+
+    if ((packet->afc_flags & 0x40) && (packet->afc_flags & 0x10) && (tspad->pending_packets != NULL) && tspad->splicing_inprogress==FALSE) {
+        //random access and PCR bits are set; Either push out buffer or initiate splicing...
+        if (tspad->splicing_inprogress == TRUE) {
+            GST_WARNING_OBJECT(parse, "New packet with random access, although splicing is already in progress. Shouldn't happen!!!!");
+        }
+        //Check if we have a splice event scheduled
+        if (tspad->program->program.spliceinfo != NULL) {
+             GST_DEBUG_OBJECT(parse, "Splice event exists. PTS:%"GST_TIME_FORMAT " Offset:%" GST_TIME_FORMAT, 
+                 GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->splice_insert.pts_time)),
+                 GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(tspad->program->program.spliceinfo->pts_adjustment)));
+             //We should have a PES header in the random_access TS packet. Error if not!
+             if (mpegts_parse_pes_header(packet->payload, packet->data_end - packet->payload, &pes) == PES_PARSING_OK) {
+                 GST_DEBUG_OBJECT(parse, "PES header parsed with result PES_PARSING_OK; PID:0x%04x, PTS:%" GST_TIME_FORMAT, 
+                     packet->pid, GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)));
+                if (tspad->program->program.spliceinfo->splice_insert.pts_time < pes.PTS) {
+                    //Looks like a splicing point, send downstream event....
+                    tspad->splicing_inprogress = TRUE;
+                    tspad->program->program.streams[packet->pid]->already_spliced = TRUE;
+                    if (tspad->spliced_packets == NULL) {
+                        //Allocate a temp buffer for the packets that should go to the next buffer....
+                        //gst_debug_set_threshold_from_string("3,tsparse:6", TRUE);
+                        tspad->spliced_packets = gst_buffer_new();
+                        memory_counter = 0;
+                        if (packet->afc_flags & 0x10) { //packet has PCR
+                            GST_BUFFER_PTS(tspad->spliced_packets) = current_timestamp;
+                            GST_BUFFER_OFFSET(tspad->spliced_packets) = packet->offset;
+                            GST_BUFFER_DURATION(tspad->pending_packets) = GST_BUFFER_PTS(tspad->spliced_packets) - GST_BUFFER_PTS(tspad->pending_packets);
+                            if (set_packet_discontinuity_flag(parse,packet) == FALSE) {
+                                GST_WARNING_OBJECT(parse, "Setting discontinuity flag failed! Expect problems!");
+                            }
+                            GST_DEBUG_OBJECT(parse, "Started new spliced buffer with PCR:%" GST_TIME_FORMAT " Timestamp:%" GST_TIME_FORMAT,
+                                GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                                GST_TIME_ARGS(GST_BUFFER_PTS(tspad->spliced_packets)));
+                        }
+                    }
+                }
+            }
+        }
+        else if (parse->parent.parse_private_sections==TRUE) {  //No splice event scheduled, let's check buffer duration and send force_key_unit event if duration is more than 15sec
+            GST_DEBUG_OBJECT(parse,"last_splice_ts:%"GST_TIME_FORMAT " , packet ts:%" GST_TIME_FORMAT, 
+                GST_TIME_ARGS(tspad->last_splice_ts),
+                GST_TIME_ARGS(current_timestamp));
+            if (tspad->last_splice_ts + 15*GST_SECOND < current_timestamp) {
+                mpegts_parse_pes_header(packet->payload, packet->data_end - packet->payload, &pes);
+                GST_DEBUG_OBJECT(parse,"Ad-hoc splicing initiated at PCR:%" GST_TIME_FORMAT " Timestamp:%" GST_TIME_FORMAT, 
+                    GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+                    GST_TIME_ARGS(current_timestamp));
+                ad_hoc_splice = TRUE;
+             /*   if (set_packet_discontinuity_flag(parse, packet) == FALSE) {
+                    GST_WARNING_OBJECT(parse, "Setting discontinuity flag failed! Expect problems!");
+                } */
+            }
+        }
+    }
+    if (tspad->splicing_inprogress == TRUE)
+        all_streams_spliced = mpegts_parse_tspad_all_streams_spliced(tspad, packet->pid);
+    else
+        all_streams_spliced = FALSE;
+   
+    if ((tspad->splicing_inprogress == FALSE && ((packet->afc_flags & 0x40) && (packet->afc_flags & 0x10) && (tspad->pending_packets != NULL))) ||
+        (tspad->splicing_inprogress && all_streams_spliced) ||
+        (ad_hoc_splice==TRUE)) {
+
+        //This is the generic part, we should push out the pending packets either if splicing or just found a random_access packet
+        GST_DEBUG_OBJECT(parse, "Pushing pending buffer to tspad...");
+        ret = gst_pad_push(tspad->pad, tspad->pending_packets);
+        ret = gst_flow_combiner_update_flow(parse->flowcombiner, ret);
+        GST_DEBUG_OBJECT(parse, "Pushed out pending packets with result:%s. Timestamp:%" GST_TIME_FORMAT
+            " DUR:%" GST_TIME_FORMAT, gst_flow_get_name(ret), GST_TIME_ARGS(GST_BUFFER_PTS(tspad->pending_packets)),
+            GST_TIME_ARGS(GST_BUFFER_DURATION(tspad->pending_packets)));
+        
+        if ((packet->afc_flags & 0x80) && (packet->afc_flags & 0x10)) {
+            //We have discountinuity flag set in the packet. Send a new segment event.
+            GstSegment seg;
+            gst_segment_init(&seg, GST_FORMAT_TIME);
+            seg.start = current_timestamp;
+            seg.flags = GST_SEGMENT_FLAG_RESET;
+            GST_INFO_OBJECT(parse,
+                "Discontinuity detected. Generating time output segment %" GST_SEGMENT_FORMAT, &seg);
+            //gst_pad_push_event(tspad->pad, gst_event_new_segment(&seg));
+        }
+
+        tspad->pending_packets = NULL;
+
+        if ((tspad->splicing_inprogress && all_streams_spliced)||(ad_hoc_splice==TRUE)) {
+            //If splicing, send out the force_key_unit event.
+            if (ad_hoc_splice == TRUE) {
+                tspad->last_splice_ts = current_timestamp;
+                splice_event_id = ++splice_event_index%2;
+            }
+            else {
+                tspad->last_splice_ts = GST_BUFFER_PTS(tspad->spliced_packets);
+                splice_event_id = tspad->program->program.spliceinfo->splice_insert.splice_event_id;
+            }
+            GST_DEBUG_OBJECT(parse, "Sending force_key_unit event. Splice timestamp:%" GST_TIME_FORMAT " PTS:%" GST_TIME_FORMAT " EventID:%i",
+                GST_TIME_ARGS(tspad->last_splice_ts),
+                GST_TIME_ARGS(MPEGTIME_TO_GSTTIME(pes.PTS)),
+                splice_event_id);
+            GstEvent *spliceevent;
+            spliceevent = gst_video_event_new_downstream_force_key_unit(GST_CLOCK_TIME_NONE,/*tspad->last_splice_ts,*/ GST_CLOCK_TIME_NONE, GST_CLOCK_TIME_NONE, FALSE, splice_event_id);
+            gst_pad_push_event(tspad->pad, spliceevent); 
+            tspad->program->program.spliceinfo = NULL; //delete splice event as we've already served it.
+            tspad->has_pat = FALSE;
+            tspad->has_pmt = FALSE;
+            if (GST_IS_BUFFER(tspad->spliced_packets)) {
+                gst_buffer_insert_memory(tspad->spliced_packets, 0, tspad->pmt);
+                gst_buffer_insert_memory(tspad->spliced_packets, 0, tspad->pat);
+            }
+            tspad->pending_packets = tspad->spliced_packets;
+            tspad->pat = tspad->pmt = NULL;
+            tspad->splicing_inprogress = FALSE;
+            tspad->spliced_packets = NULL;
+            g_list_foreach(tspad->program->program.stream_list, (GFunc)stream_clear_spliced_flag, NULL);
+            ad_hoc_splice = FALSE;
+            //gst_debug_set_threshold_from_string("3,tsparse:5", TRUE);
+        }
+    }
+            
+    if (tspad->pending_packets == NULL) {
+        //This is the first packet after start or pushing everything out except splicing
+        GST_DEBUG_OBJECT(parse,"Start new buffer with PCR:%" GST_TIME_FORMAT " Timestamp:%" GST_TIME_FORMAT, 
+            GST_TIME_ARGS(PCRTIME_TO_GSTTIME(packet->pcr)),
+            GST_TIME_ARGS(current_timestamp));
+        tspad->pending_packets = gst_buffer_new();
+        if (packet->afc_flags & 0x10) { //packet has PCR
+            GST_BUFFER_PTS(tspad->pending_packets) = current_timestamp;
+            GST_BUFFER_OFFSET(tspad->pending_packets)=packet->offset;
+        }
+    }
+    //Fix CC
+    if (!set_packet_cc(parse,tspad, packet)) {
+        GST_LOG_OBJECT(parse, "Could set CC for PID:0x%0x", packet->pid);
+    }
+    //Copy packet data to the allocated memory
+    GST_LOG_OBJECT(parse, "Adding memory to buffer.");
+    gst_memory_map(mem, &info, GST_MAP_WRITE);
+    memcpy(info.data, packet->data_start, packet->data_end - packet->data_start);
+    gst_memory_unmap(mem, &info);
+    //Decide if we have to add the memory to the pending_packet or to the splicing_packet buffer
+    if (tspad->splicing_inprogress) {
+        if (mpegts_parse_tspad_pid_spliced(tspad, packet->pid)) {
+            actual_buffer = tspad->spliced_packets;
+            GST_LOG_OBJECT(parse, "Using splicing buffer.");
+        }
+        else {
+            actual_buffer = tspad->pending_packets;
+            GST_LOG_OBJECT(parse,"Using pending buffer.");
+        }
+    }
+    else {
+        actual_buffer = tspad->pending_packets;
+    }
+    if ((GST_BUFFER_PTS_IS_VALID(actual_buffer)) && !(packet->afc_flags & 0x80) && (packet->afc_flags & 0x10) && tspad->spliced_packets==NULL) {
+        GST_BUFFER_DURATION(actual_buffer) = current_timestamp - GST_BUFFER_PTS(actual_buffer);
+        GST_BUFFER_OFFSET_END(actual_buffer) = packet->offset;
+    }
+    
+    if (section != NULL) {
+        if (section->table_id == 0x00 && tspad->has_pat==FALSE && tspad->splicing_inprogress) {
+//            gst_buffer_insert_memory(actual_buffer, 0, mem);
+            tspad->has_pat = TRUE;
+            tspad->pat = mem;
+            GST_DEBUG_OBJECT(parse, "PAT saved to tspad.");
+        } else if (section->table_id == 0x02 && tspad->has_pmt==FALSE && tspad->splicing_inprogress) {
+//            gst_buffer_insert_memory(actual_buffer, 1, mem);
+            tspad->has_pmt = TRUE;
+            tspad->pmt = mem;
+            GST_DEBUG_OBJECT(parse, "PMT saved to tspad");
+        }
+        else {
+            gst_buffer_append_memory(actual_buffer, mem);
+            GST_LOG_OBJECT(parse, "Packet with PID:0x%04x appended to buffer.", packet->pid);
+        }
+    } else {
+        gst_buffer_append_memory(actual_buffer, mem);
+        GST_LOG_OBJECT(parse, "Packet with PID:0x%04x appended to buffer.", packet->pid);
+    }
+    return ret;
+}
+
 static GstFlowReturn
 mpegts_parse_tspad_push_section (MpegTSParse2 * parse, MpegTSParsePad * tspad,
     GstMpegtsSection * section, MpegTSPacketizerPacket * packet)
@@ -549,17 +1078,12 @@ mpegts_parse_tspad_push_section (MpegTSParse2 * parse, MpegTSParsePad * tspad,
     }
   }
 
-  GST_DEBUG_OBJECT (parse,
+  GST_LOG_OBJECT (parse,
       "pushing section: %d program number: %d table_id: %d", to_push,
       tspad->program_number, section->table_id);
 
   if (to_push) {
-    GstBuffer *buf =
-        gst_buffer_new_and_alloc (packet->data_end - packet->data_start);
-    gst_buffer_fill (buf, 0, packet->data_start,
-        packet->data_end - packet->data_start);
-    ret = gst_pad_push (tspad->pad, buf);
-    ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+      ret = mpegts_parse_tspad_queue_packet(parse, tspad, packet,section);
   }
 
   GST_LOG_OBJECT (parse, "Returning %s", gst_flow_get_name (ret));
@@ -572,7 +1096,6 @@ mpegts_parse_tspad_push (MpegTSParse2 * parse, MpegTSParsePad * tspad,
 {
   GstFlowReturn ret = GST_FLOW_OK;
   MpegTSBaseProgram *bp = NULL;
-
   if (tspad->program_number != -1) {
     if (tspad->program)
       bp = (MpegTSBaseProgram *) tspad->program;
@@ -580,24 +1103,15 @@ mpegts_parse_tspad_push (MpegTSParse2 * parse, MpegTSParsePad * tspad,
       bp = mpegts_base_get_program ((MpegTSBase *) parse,
           tspad->program_number);
   }
-
   if (bp) {
     if (packet->pid == bp->pmt_pid || bp->streams == NULL
         || bp->streams[packet->pid]) {
-      GstBuffer *buf =
-          gst_buffer_new_and_alloc (packet->data_end - packet->data_start);
-      gst_buffer_fill (buf, 0, packet->data_start,
-          packet->data_end - packet->data_start);
-      /* push if there's no filter or if the pid is in the filter */
-      ret = gst_pad_push (tspad->pad, buf);
-      ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+        ret = mpegts_parse_tspad_queue_packet(parse, tspad, packet,NULL);
     }
   }
-  GST_DEBUG_OBJECT (parse, "Returning %s", gst_flow_get_name (ret));
-
   return ret;
 }
-
+ 
 static void
 pad_clear_for_push (GstPad * pad, MpegTSParse2 * parse)
 {
@@ -671,7 +1185,7 @@ mpegts_parse_push (MpegTSBase * base, MpegTSPacketizerPacket * packet,
         pads_cookie = GST_ELEMENT_CAST (parse)->pads_cookie;
         srcpads = parse->srcpads;
       } else {
-        GST_DEBUG ("getting next pad");
+        GST_LOG ("getting next pad");
         /* Get next pad */
         srcpads = g_list_next (srcpads);
       }
@@ -708,7 +1222,7 @@ mpegts_parse_inspect_packet (MpegTSBase * base, MpegTSPacketizerPacket * packet)
     if (parse->pcr_pid == packet->pid) {
       parse->current_pcr = mpegts_packetizer_pts_to_ts (base->packetizer,
           PCRTIME_TO_GSTTIME (packet->pcr), parse->pcr_pid);
-      GST_DEBUG ("Got new PCR %" GST_TIME_FORMAT " raw %" G_GUINT64_FORMAT,
+      GST_LOG ("Got new PCR %" GST_TIME_FORMAT " raw %" G_GUINT64_FORMAT,
           GST_TIME_ARGS (parse->current_pcr), packet->pcr);
       if (parse->base_pcr == GST_CLOCK_TIME_NONE) {
         parse->base_pcr = parse->current_pcr;
@@ -744,9 +1258,9 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstClockTime start_ts;
-  GstClockTime pcr = GST_CLOCK_TIME_NONE;
-  GstClockTime pcr_diff = 0;
-  gsize pcr_bytes, bytes_since_pcr, pos;
+  GstClockTime pcr = GST_CLOCK_TIME_NONE, dur;
+  GstClockTime pcr_diff = 0,out_ts;
+  gsize pcr_bytes, bytes_since_pcr, pos, buf_size;
   GstBuffer *buffer;
   GList *l, *end = NULL;
 
@@ -792,7 +1306,8 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
 
   /* Case 2 */
   if (!GST_CLOCK_TIME_IS_VALID (parse->previous_pcr)) {
-    pcr_diff = get_pending_timestamp_diff (parse);
+      GST_FIXME("There is no previous PCR, should happen only at the beginning.");
+     pcr_diff = get_pending_timestamp_diff (parse);
 
     /* Calculate the start_ts that ends at the end timestamp */
     start_ts = GST_CLOCK_TIME_NONE;
@@ -802,48 +1317,58 @@ drain_pending_buffers (MpegTSParse2 * parse, gboolean drain_all)
         start_ts -= pcr_diff;
     }
   } else if (drain_all) {       /* Case 3 */
-    start_ts = parse->previous_pcr;
-    pcr_diff = get_pending_timestamp_diff (parse);
+      GST_FIXME("drain_all is set. Should happen only at EOS.");
+      start_ts = parse->previous_pcr;
+      pcr_diff = get_pending_timestamp_diff (parse);
   } else {                      /* Case 4 */
     start_ts = parse->previous_pcr;
     if (GST_CLOCK_TIME_IS_VALID (pcr) && pcr > start_ts)
       pcr_diff = GST_CLOCK_DIFF (start_ts, pcr);
 
     /* Make sure PCR observations are sufficiently far apart */
-    if (drain_all == FALSE && pcr_diff < parse->smoothing_latency)
-      return GST_FLOW_OK;
+    if (drain_all == FALSE && pcr_diff < parse->smoothing_latency) {
+        GST_FIXME("pcr_diff is smaller than smoothing_latency. Not doing anything...");
+        return GST_FLOW_OK;
+    }
   }
 
-  GST_INFO_OBJECT (parse, "Pushing buffers - startTS %" GST_TIME_FORMAT
+  GST_LOG_OBJECT (parse, "Pushing buffers - startTS %" GST_TIME_FORMAT
       " duration %" GST_TIME_FORMAT " %" G_GSIZE_FORMAT " bytes",
       GST_TIME_ARGS (start_ts), GST_TIME_ARGS (pcr_diff), pcr_bytes);
 
   /* Now, push buffers out pacing timestamps over pcr_diff time and pcr_bytes */
   pos = 0;
   l = g_list_last (parse->pending_buffers);
+  out_ts = start_ts;
   while (l != end) {
     GList *p;
-    GstClockTime out_ts = start_ts;
-
     buffer = gst_buffer_make_writable (GST_BUFFER (l->data));
+    buf_size = gst_buffer_get_size(buffer);
 
     if (out_ts != GST_CLOCK_TIME_NONE && pcr_diff != GST_CLOCK_TIME_NONE &&
         pcr_bytes && pos)
-      out_ts += gst_util_uint64_scale (pcr_diff, pos, pcr_bytes);
+      out_ts = start_ts+gst_util_uint64_scale (pcr_diff, pos, pcr_bytes);
 
-    pos += gst_buffer_get_size (buffer);
+    if(pcr_bytes>0)
+        dur=gst_util_uint64_scale(pcr_diff,buf_size,pcr_bytes);
+    else {
+        dur=GST_CLOCK_TIME_NONE;
+        //dur = 0;
+    }
 
-    GST_DEBUG_OBJECT (parse,
-        "InputTS %" GST_TIME_FORMAT " out %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (GST_BUFFER_PTS (buffer)), GST_TIME_ARGS (out_ts));
+    GST_LOG_OBJECT (parse,
+        "InputTS %" GST_TIME_FORMAT " out %" GST_TIME_FORMAT " dur %" GST_TIME_FORMAT " bytes %" G_GSIZE_FORMAT, 
+        GST_TIME_ARGS (GST_BUFFER_PTS (buffer)), GST_TIME_ARGS (out_ts), GST_TIME_ARGS (dur),buf_size);
 
     GST_BUFFER_PTS (buffer) = out_ts + parse->ts_offset;
     GST_BUFFER_DTS (buffer) = out_ts + parse->ts_offset;
+    GST_BUFFER_DURATION (buffer) = dur;
     if (ret == GST_FLOW_OK) {
       ret = gst_pad_push (parse->srcpad, buffer);
       ret = gst_flow_combiner_update_flow (parse->flowcombiner, ret);
+      pos += buf_size;
     } else
-      gst_buffer_unref (buffer);
+        gst_buffer_unref (buffer);
 
     /* Free this list node and move to the next */
     p = g_list_previous (l);
@@ -866,7 +1391,7 @@ mpegts_parse_input_done (MpegTSBase * base, GstBuffer * buffer)
   GST_LOG_OBJECT (parse, "Received buffer %" GST_PTR_FORMAT, buffer);
 
   if (parse->current_pcr != GST_CLOCK_TIME_NONE) {
-    GST_DEBUG_OBJECT (parse,
+    GST_LOG_OBJECT (parse,
         "InputTS %" GST_TIME_FORMAT " PCR %" GST_TIME_FORMAT,
         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
         GST_TIME_ARGS (parse->current_pcr));
diff --git a/gst/mpegtsmux/mpegtsmux.c b/gst/mpegtsmux/mpegtsmux.c
index 58b1009..53f7498 100644
--- a/gst/mpegtsmux/mpegtsmux.c
+++ b/gst/mpegtsmux/mpegtsmux.c
@@ -122,10 +122,10 @@ enum
 #define MPEGTSMUX_DEFAULT_M2TS         FALSE
 
 static GstStaticPadTemplate mpegtsmux_sink_factory =
-    GST_STATIC_PAD_TEMPLATE ("sink_%d",
+GST_STATIC_PAD_TEMPLATE("sink_%d",
     GST_PAD_SINK,
     GST_PAD_REQUEST,
-    GST_STATIC_CAPS ("video/mpeg, "
+    GST_STATIC_CAPS("video/mpeg, "
         "parsed = (boolean) TRUE, "
         "mpegversion = (int) { 1, 2, 4 }, "
         "systemstream = (boolean) false; "
@@ -156,6 +156,7 @@ static GstStaticPadTemplate mpegtsmux_sink_factory =
         "channels = (int) [1, 8], "
         "channel-mapping-family = (int) {0, 1};"
         "subpicture/x-dvb; application/x-teletext; meta/x-klv, parsed=true;"
+        "application/spliceinfo;"
         "image/x-jpc, profile = (int)[0, 49151];"));
 
 static GstStaticPadTemplate mpegtsmux_src_factory =
@@ -201,6 +202,7 @@ static gboolean mpegtsmux_send_event (GstElement * element, GstEvent * event);
 static void mpegtsmux_set_header_on_caps (MpegTsMux * mux);
 static gboolean mpegtsmux_src_event (GstPad * pad, GstObject * parent,
     GstEvent * event);
+static GstFlowReturn mpegtsmux_create_streams(MpegTsMux* mux, GstCollectData **best);
 
 #if 0
 static void mpegtsmux_set_index (GstElement * element, GstIndex * index);
@@ -307,6 +309,106 @@ mpegtsmux_class_init (MpegTsMuxClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
+static gint 
+mpegtsmux_compare_timestamps(MpegTsMux *mux, GstCollectData *data1, GstCollectData *data2)
+{
+    GstClockTime ts1, ts2;
+    if (data1 == NULL || data2 == NULL) {
+        GST_ERROR("Cannot compare the timestamps of buffers. One of them is NULL!");
+            return 0;
+    }
+    if (GST_BUFFER_DTS(data1->buffer) != GST_CLOCK_TIME_NONE)
+        ts1 = GST_BUFFER_DTS(data1->buffer);
+    else
+        ts1 = GST_BUFFER_PTS(data1->buffer);
+
+    if (GST_BUFFER_DTS(data2->buffer) != GST_CLOCK_TIME_NONE)
+        ts2 = GST_BUFFER_DTS(data2->buffer);
+    else
+        ts2 = GST_BUFFER_PTS(data2->buffer);
+    GST_INFO_OBJECT(mux, "Comparing Pad:%s ts:%"GST_TIME_FORMAT " DTS:%" GST_TIME_FORMAT " with Pad:%s ts:%"GST_TIME_FORMAT " DTS:%"GST_TIME_FORMAT,
+        GST_PAD_NAME(data1->pad), GST_TIME_ARGS(ts1), GST_TIME_ARGS(GST_COLLECT_PADS_DTS(data1)), 
+        GST_PAD_NAME(data2->pad), GST_TIME_ARGS(ts2),GST_TIME_ARGS(GST_COLLECT_PADS_DTS(data2)));
+    if (ts1 < ts2)
+        return -1;
+    else if (ts2 < ts1)
+        return 1;
+    else
+        return 0;
+}
+static void
+mpegtsmux_collect_pads_find_best_pad(MpegTsMux *mux, GstCollectPads * pads,
+    GstCollectData ** data, GstClockTime * time)
+{
+    GSList *collected;
+    GstCollectData *best = NULL;
+    GstCollectData *video = NULL;
+    GstClockTime best_time = GST_CLOCK_TIME_NONE;
+
+    g_return_if_fail(data != NULL);
+    g_return_if_fail(time != NULL);
+
+    if (G_UNLIKELY(mux->first)) {
+        mpegtsmux_create_streams(mux,&best);
+        mpegtsmux_prepare_srcpad(mux);
+        mux->first = FALSE;
+    } 
+    if(best==NULL) {
+        for (collected = pads->data; collected; collected = g_slist_next(collected)) {
+            GstBuffer *buffer;
+            GstCollectData *data = (GstCollectData *)collected->data;
+            MpegTsPadData *ts_data = (MpegTsPadData *)collected->data;
+            GstClockTime timestamp;
+
+            buffer = gst_collect_pads_peek(pads, data);
+            /* if we have a buffer check if it is better then the current best one */
+            if (buffer != NULL) {
+                timestamp = GST_BUFFER_DTS(buffer);
+                if (!GST_CLOCK_TIME_IS_VALID(timestamp)) {
+                    timestamp = GST_BUFFER_PTS(buffer);
+                }
+                gst_buffer_unref(buffer);
+                if (best == NULL || best_time>timestamp) {
+                    best = data;
+                    best_time = timestamp;
+                }
+            }
+        }
+    }
+    *data = best;
+    *time = best_time;
+    GST_DEBUG_OBJECT(pads, "best pad %s, best time %" GST_TIME_FORMAT,
+        best ? GST_PAD_NAME(((GstCollectData *)best)->pad) : "(nil)",
+        GST_TIME_ARGS(best_time));
+}
+
+static GstFlowReturn
+mpegtsmux_collected(GstCollectPads *pads, gpointer user_data)
+{
+    GstFlowReturn ret = GST_FLOW_OK;
+    MpegTsMux *mux = (MpegTsMux*)user_data;
+    GSList *walk = mux->collect->data;
+    GstCollectData* data;
+    GstClockTime ts;
+    data = (GstCollectData *)walk->data;
+/*    while (walk) {
+        GstCollectData *c_data = (GstCollectData *)walk->data;
+        if (mpegtsmux_compare_timestamps( mux, data, c_data) < 0)
+            data = c_data;
+        walk = g_slist_next(walk);
+    } */
+    mpegtsmux_collect_pads_find_best_pad(mux, pads, &data, &ts);
+    if (data != NULL) {
+        GST_INFO_OBJECT(mux, "Oldest buffer is in Pad:%s with ts:%"GST_TIME_FORMAT,
+            GST_PAD_NAME(data->pad), GST_TIME_ARGS(ts));
+        return mpegtsmux_collected_buffer(pads, data, gst_collect_pads_pop(mux->collect, data), user_data);
+    }
+    else {
+        return mpegtsmux_collected_buffer(pads, NULL, NULL, user_data);
+    }
+
+}
+
 static void
 mpegtsmux_init (MpegTsMux * mux)
 {
@@ -318,16 +420,26 @@ mpegtsmux_init (MpegTsMux * mux)
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
   mux->collect = gst_collect_pads_new ();
+/*
   gst_collect_pads_set_buffer_function (mux->collect,
       (GstCollectPadsBufferFunction)
       GST_DEBUG_FUNCPTR (mpegtsmux_collected_buffer), mux);
+*/
+  gst_collect_pads_set_function(mux->collect,
+      (GstCollectPadsFunction)
+      GST_DEBUG_FUNCPTR(mpegtsmux_collected), mux);
+
 
   gst_collect_pads_set_event_function (mux->collect,
       (GstCollectPadsEventFunction) GST_DEBUG_FUNCPTR (mpegtsmux_sink_event),
       mux);
   gst_collect_pads_set_clip_function (mux->collect, (GstCollectPadsClipFunction)
       GST_DEBUG_FUNCPTR (mpegtsmux_clip_inc_running_time), mux);
+/*
+  gst_collect_pads_set_compare_function(mux->collect, (GstCollectPadsCompareFunction)
+      GST_DEBUG_FUNCPTR(mpegtsmux_compare_timestamps), mux);
 
+*/
   mux->adapter = gst_adapter_new ();
   mux->out_adapter = gst_adapter_new ();
 
@@ -633,6 +745,7 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
     st = TSMUX_ST_VIDEO_HEVC;
   } else if (strcmp (mt, "audio/mpeg") == 0) {
     gint mpegversion;
+    gint layer;
 
     if (!gst_structure_get_int (s, "mpegversion", &mpegversion)) {
       GST_ERROR_OBJECT (pad, "caps missing mpegversion");
@@ -664,6 +777,17 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
         GST_WARNING_OBJECT (pad, "unsupported mpegversion %d", mpegversion);
         goto not_negotiated;
     }
+    if (!gst_structure_get_int(s, "layer", &layer)) {
+        GST_ERROR_OBJECT(pad, "caps missing layer");
+        goto not_negotiated;
+    }
+
+    switch (layer) {
+    case 2:
+        st = TSMUX_ST_AUDIO_MPEG2;
+        break;
+    }
+
   } else if (strcmp (mt, "video/mpeg") == 0) {
     gint mpegversion;
 
@@ -692,7 +816,9 @@ mpegtsmux_create_stream (MpegTsMux * mux, MpegTsPadData * ts_data)
     st = TSMUX_ST_PS_TELETEXT;
     /* needs a particularly sized layout */
     ts_data->prepare_func = mpegtsmux_prepare_teletext;
-  } else if (strcmp (mt, "audio/x-opus") == 0) {
+  } else if(strcmp(mt, "application/spliceinfo") == 0) {
+      st = 134; //Streamtype:Spliceinfo FIXME: Set TSMUX_ST_SPLICEINFO to 134
+  } else if (strcmp(mt, "audio/x-opus") == 0) {
     guint8 channels, mapping_family, stream_count, coupled_count;
     guint8 channel_mapping[256];
 
@@ -920,7 +1046,7 @@ not_negotiated:
 }
 
 static GstFlowReturn
-mpegtsmux_create_streams (MpegTsMux * mux)
+mpegtsmux_create_streams (MpegTsMux * mux, GstCollectData ** best)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GSList *walk = mux->collect->data;
@@ -930,7 +1056,7 @@ mpegtsmux_create_streams (MpegTsMux * mux)
     GstCollectData *c_data = (GstCollectData *) walk->data;
     MpegTsPadData *ts_data = (MpegTsPadData *) walk->data;
     gchar *name = NULL;
-    gchar *pcr_name;
+    gchar *pcr_name, *pmt_name;
 
     walk = g_slist_next (walk);
 
@@ -973,6 +1099,7 @@ mpegtsmux_create_streams (MpegTsMux * mux)
           ts_data->pid, ts_data->prog_id);
 
       tsmux_program_set_pcr_stream (ts_data->prog, ts_data->stream);
+      *best = (GstCollectData*)ts_data;
     }
 
     if (ts_data->stream == NULL) {
@@ -994,6 +1121,19 @@ mpegtsmux_create_streams (MpegTsMux * mux)
       }
     }
     g_free (pcr_name);
+
+    /* Check for user-specified PMT PID */
+    pmt_name = g_strdup_printf("PMT_%d", ts_data->prog->pgm_number);
+    if (mux->prog_map && gst_structure_has_field(mux->prog_map, pmt_name)) {
+        guint pmt_pid;
+        gst_structure_get_int(mux->prog_map, pmt_name,&pmt_pid);        
+        GST_DEBUG_OBJECT(mux, "Structure:%s", gst_structure_to_string(mux->prog_map));
+        GST_DEBUG_OBJECT(mux, "User specified pid=%i as PMT pid for "
+           "program (prog_id = %d)", pmt_pid, ts_data->prog->pgm_number);
+        tsmux_program_set_pmt_pid(mux->tsmux, ts_data->prog, pmt_pid);
+    }
+    g_free(pmt_name);
+
   }
 
   return GST_FLOW_OK;
@@ -1348,18 +1488,6 @@ mpegtsmux_collected_buffer (GstCollectPads * pads, GstCollectData * data,
 
   GST_DEBUG_OBJECT (mux, "Pads collected");
 
-  if (G_UNLIKELY (mux->first)) {
-    ret = mpegtsmux_create_streams (mux);
-    if (G_UNLIKELY (ret != GST_FLOW_OK)) {
-      if (buf)
-        gst_buffer_unref (buf);
-      return ret;
-    }
-
-    mpegtsmux_prepare_srcpad (mux);
-
-    mux->first = FALSE;
-  }
 
   if (G_UNLIKELY (best == NULL)) {
     /* EOS */
@@ -1372,7 +1500,7 @@ mpegtsmux_collected_buffer (GstCollectPads * pads, GstCollectData * data,
     if (buf)
       gst_buffer_unref (buf);
 
-    return GST_FLOW_OK;
+    return GST_FLOW_EOS;
   }
 
   prog = best->prog;
diff --git a/gst/mpegtsmux/tsmux/tsmux.c b/gst/mpegtsmux/tsmux/tsmux.c
index 6fa9e0d..2d42f06 100644
--- a/gst/mpegtsmux/tsmux/tsmux.c
+++ b/gst/mpegtsmux/tsmux/tsmux.c
@@ -104,7 +104,7 @@
 /* HACK: We use a fixed buffering offset for the PCR at the moment - 
  * this is the amount 'in advance' of the stream that the PCR sits.
  * 1/8 second atm */
-#define TSMUX_PCR_OFFSET (TSMUX_CLOCK_FREQ / 8)
+#define TSMUX_PCR_OFFSET (TSMUX_CLOCK_FREQ / 2)
 
 /* Times per second to write PCR */
 #define TSMUX_DEFAULT_PCR_FREQ (25)
@@ -512,6 +512,19 @@ tsmux_program_set_pcr_stream (TsMuxProgram * program, TsMuxStream * stream)
 
   program->pmt_changed = TRUE;
 }
+void
+tsmux_program_set_pmt_pid( TsMux *mux, TsMuxProgram * program, guint pmt_pid)
+{
+    g_return_if_fail(program != NULL);
+
+    if (program->pmt_pid == pmt_pid)
+        return;
+
+    program->pmt_pid = pmt_pid;
+
+    mux->pat_changed = TRUE;
+}
+
 
 /**
  * tsmux_get_new_pid:
diff --git a/gst/mpegtsmux/tsmux/tsmux.h b/gst/mpegtsmux/tsmux/tsmux.h
index 11a1480..924b23d 100644
--- a/gst/mpegtsmux/tsmux/tsmux.h
+++ b/gst/mpegtsmux/tsmux/tsmux.h
@@ -211,6 +211,7 @@ TsMuxStream *	tsmux_find_stream 		(TsMux *mux, guint16 pid);
 
 void 		tsmux_program_add_stream 	(TsMuxProgram *program, TsMuxStream *stream);
 void 		tsmux_program_set_pcr_stream 	(TsMuxProgram *program, TsMuxStream *stream);
+void 		tsmux_program_set_pmt_pid (TsMux *mux,TsMuxProgram *program, guint pmt_pid);
 
 /* writing stuff */
 gboolean 	tsmux_write_stream_packet 	(TsMux *mux, TsMuxStream *stream);
diff --git a/gst/mpegtsmux/tsmux/tsmuxstream.c b/gst/mpegtsmux/tsmux/tsmuxstream.c
index ff68dff..6385a7a 100644
--- a/gst/mpegtsmux/tsmux/tsmuxstream.c
+++ b/gst/mpegtsmux/tsmux/tsmuxstream.c
@@ -229,6 +229,7 @@ tsmux_stream_new (guint16 pid, TsMuxStreamType stream_type)
 
   stream->pcr_ref = 0;
   stream->last_pcr = -1;
+  stream->first_packet = TRUE;
 
   return stream;
 }
@@ -432,10 +433,12 @@ tsmux_stream_initialize_pes_packet (TsMuxStream * stream)
   stream->pi.flags &= ~(TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS |
       TSMUX_PACKET_FLAG_PES_WRITE_PTS);
 
-  if (GST_CLOCK_STIME_IS_VALID (stream->pts)
-      && GST_CLOCK_STIME_IS_VALID (stream->dts)
-      && stream->pts != stream->dts)
-    stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS;
+  if (GST_CLOCK_STIME_IS_VALID(stream->pts)
+      && GST_CLOCK_STIME_IS_VALID(stream->dts)
+      && stream->pts != stream->dts) {
+      stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS;
+      stream->pi.flags |= TSMUX_PACKET_FLAG_WRITE_PCR;
+  }
   else {
     if (GST_CLOCK_STIME_IS_VALID (stream->pts))
       stream->pi.flags |= TSMUX_PACKET_FLAG_PES_WRITE_PTS;
@@ -446,6 +449,12 @@ tsmux_stream_initialize_pes_packet (TsMuxStream * stream)
     if (buf->random_access) {
       stream->pi.flags |= TSMUX_PACKET_FLAG_RANDOM_ACCESS;
       stream->pi.flags |= TSMUX_PACKET_FLAG_ADAPTATION;
+      stream->pi.flags |= TSMUX_PACKET_FLAG_WRITE_PCR;
+    }
+    if (stream->first_packet) {
+        stream->pi.flags |= TSMUX_PACKET_FLAG_ADAPTATION;
+        stream->pi.flags |= TSMUX_PACKET_FLAG_DISCONT;
+        stream->first_packet = FALSE;
     }
   }
 
@@ -716,8 +725,10 @@ tsmux_stream_add_data (TsMuxStream * stream, guint8 * data, guint len,
   packet->pts = pts;
   packet->dts = dts;
 
-  if (stream->bytes_avail == 0)
-    stream->last_pts = pts;
+  if (stream->bytes_avail == 0) {
+      stream->last_dts = dts;
+      stream->last_pts = pts;
+  }
 
   stream->bytes_avail += len;
   stream->buffers = g_list_append (stream->buffers, packet);
@@ -1092,5 +1103,5 @@ tsmux_stream_get_pts (TsMuxStream * stream)
 {
   g_return_val_if_fail (stream != NULL, GST_CLOCK_STIME_NONE);
 
-  return stream->last_pts;
+  return stream->last_dts;
 }
diff --git a/gst/mpegtsmux/tsmux/tsmuxstream.h b/gst/mpegtsmux/tsmux/tsmuxstream.h
index 7edfb61..db41cd6 100644
--- a/gst/mpegtsmux/tsmux/tsmuxstream.h
+++ b/gst/mpegtsmux/tsmux/tsmuxstream.h
@@ -227,6 +227,7 @@ struct TsMuxStream {
   guint16 profile_and_level;
   gboolean interlace_mode;
   guint8 color_spec;
+  gboolean first_packet;
 };
 
 /* stream management */
diff --git a/gst-libs/gst/mpegts/gst-scte-section.c b/gst-libs/gst/mpegts/gst-scte-section.c
new file mode 100644
index 0000000..fcdafbc
--- /dev/null
+++ b/gst-libs/gst/mpegts/gst-scte-section.c
@@ -0,0 +1,158 @@
+/*
+  * Copyright (C) 2019 Lajos Okos
+  *
+  * Authors:
+  *   Lajos Okos <lajos.okos@gmail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+*/
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+ 
+#include "mpegts.h"
+#include "gstmpegts-private.h"
+
+static void
+_gst_mpegts_scte_splice_command_free (GstMpegtsScteSpliceInsert *spinsert)
+{
+   //g_ptr_array_unref (spinfo->???);
+   //g_ptr_array_unref (spinfo->descriptors);
+   g_slice_free (GstMpegtsScteSpliceInsert, spinsert);
+}
+
+static gpointer
+_parse_scte_splice_info (GstMpegtsSection * section)
+{
+   GstMpegtsScteSpliceInfo *spinfo = NULL;
+   guint8 *data, *end;
+    
+   spinfo = g_slice_new0 (GstMpegtsScteSpliceInfo);
+ 
+   data = section->data;
+   end = data + section->section_length;
+   spinfo->table_id=*data++;
+   spinfo->section_syntax_indicator=*data>>7;
+   spinfo->private_indicator=(*data>>6)&0x01;
+   spinfo->section_length=(*data&0x0f*256) + *(data+1);
+   data+=2;
+   spinfo->protocol_version=*data++;
+   spinfo->encrypted_packet=*data>>7;
+   spinfo->encryption_algorith=(*data>>1)&0x3f;
+   spinfo->pts_adjustment=(guint64)(*data&0x01)<<32|*(data+1)<<24|*(data+2)<<16|*(data+3)<<8|*(data+4);
+   data+=5;
+   spinfo->cw_index=*data++;
+   spinfo->tier=*data<<4|(*(data+1)&0xf0)>>4;
+   spinfo->splice_command_length=(*(data+1)&0x0f)<<4|*(data+2);
+   data+=3;
+   spinfo->splice_command_type=*data++;
+   switch (spinfo->splice_command_type) {
+      case 0x05: {  //Splice Insert
+        GstMpegtsScteSpliceInsert *spinsert = &spinfo->splice_insert;
+        spinsert->splice_event_id=*data<<24|*(data+1)<<16|*(data+2)<<8|*(data+3);
+        data+=4;
+        spinsert->splice_event_cancel_indicator=*data++>>7;
+        spinsert->out_of_network_indicator=*data>>7;
+        spinsert->program_splice_flag=(*data>>6)&0x01;
+        spinsert->duration_flag=(*data>>5)&0x01;
+        spinsert->splice_immediate_flag=(*data++>>4)&0x01;
+        spinsert->time_specified_flag=*data>>7;
+        spinsert->pts_time=(((guint64)((*data)&0x01)<<32)|(*(data+1)<<24)|(*(data+2)<<16)|(*(data+3)<<8)|*(data+4)) & 0x1ffffffff;
+        data+=5;
+        spinsert->unique_program_id=*data<<8|*(data+1);
+        data+=2;
+        spinsert->avail_num=*data++;
+        spinsert->avails_expected=*data++;
+     }
+      break;
+      case 0x00:   //Splice Null
+      default: {}    //Unkown command
+        //spinfo->splice_command=NULL;
+   }
+
+   return (gpointer) spinfo;
+}
+
+static void
+_gst_mpegts_scte_splice_info_free (GstMpegtsScteSpliceInfo * spinfo)
+ {
+   //g_ptr_array_unref (spinfo->???);
+   //g_ptr_array_unref (spinfo->descriptors);
+   g_slice_free (GstMpegtsScteSpliceInfo, spinfo);
+}
+
+const GstMpegtsScteSpliceInfo *
+gst_mpegts_section_get_scte_splice_info (GstMpegtsSection * section)
+ {
+   g_return_val_if_fail (section->section_type == GST_MPEGTS_SECTION_SCTE_SPLICING,
+       NULL);
+   g_return_val_if_fail (section->cached_parsed || section->data, NULL);
+ 
+   if (!section->cached_parsed)
+     section->cached_parsed =
+         __common_section_checks (section, 3, _parse_scte_splice_info,
+         (GDestroyNotify) _gst_mpegts_scte_splice_info_free);
+ 
+   return (const GstMpegtsScteSpliceInfo *) section->cached_parsed;
+}
+
+/* 
+GstStructure should have the below fields:
+    splice-event-id (uint) : Must be present. Repeting IDs are ignored by downstream elements!!!
+    out-of-network-indicator (boolean) : 1 means exit from the network feed, 0 means return
+    pts-time (uint64) : PTS when splicing should happen
+    program-number (uint) : program number the event belons to. Used in mpegtsbase.c
+*/
+
+const GstMpegtsScteSpliceInfo*
+gst_mpegts_set_scte_splice_info(GstStructure *s)
+{
+    GstMpegtsScteSpliceInfo *spinfo = NULL;
+    GstMpegtsScteSpliceInsert *spinsert = NULL;
+
+    spinfo = g_slice_new0(GstMpegtsScteSpliceInfo);
+    spinsert = &spinfo->splice_insert;
+
+    spinfo->table_id = 0xfc; // Defined by the standard
+    spinfo->section_syntax_indicator = 0; // Defined by the standard
+    spinfo->private_indicator = 0; // Defined by the standard
+    spinfo->section_length = 0; // FIXME: Should be better calculated!!!
+    spinfo->protocol_version = 0; // Defined by the standard
+    spinfo->encrypted_packet = 0; // Defined by the standard
+    spinfo->encryption_algorith = 0; // Defined by the standard
+    spinfo->pts_adjustment = 0;
+    spinfo->cw_index = 0;
+    spinfo->tier = 0xfff;
+    spinfo->splice_command_length = 0; // FIXME: Should be better calculated!!!
+    spinfo->splice_command_type = 0x05;
+    gst_structure_get_uint(s, "splice-event-id", &spinsert->splice_event_id);
+    spinsert->splice_event_cancel_indicator = 0; // Not implemented yet. FIXME: Should be implemented sooner or later.
+    gst_structure_get_boolean(s,"out-of-network-indicator",&spinsert->out_of_network_indicator);
+    spinsert->program_splice_flag = 1;  // Program splice mode
+    spinsert->duration_flag = 0;  // No break duration ios indicated in the event
+    spinsert->splice_immediate_flag = 0;  // Splice time is present
+    spinsert->time_specified_flag = 1;  // PTS present
+    gst_structure_get_uint64(s,"pts-time",&spinsert->pts_time);
+    spinsert->unique_program_id = 0;
+    spinsert->avail_num = 0;
+    spinsert->avails_expected = 0;
+    return (const GstMpegtsScteSpliceInfo*)spinfo;
+}
